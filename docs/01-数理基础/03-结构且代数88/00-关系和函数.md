# 基石-集合论

某种程度上来说集合是不能精确定义的**基本概念**，只能大致地形容为若干个固定事物的全体，而这些事物称为元素。

关于子集、空集、幂集等基础概念不再赘述。

并、交、相对补集、绝对补集、广义并（元素的元素构成的集合）、广义交（空集不可以进行广义交）等基本运算也不再赘述。

## 有穷集的计数

包含排斥原理：设$S$为有穷集，$P_1,P_2,\dots,P_n$是n个性质.$S$中的任意元素$x$具有性质$P_i$或者不具有性质$P_i$两种情况必居其一，令$A_i$表示具有性质$P_i$的元素构成的子集，则有
$$
\begin{align}
|\bar A_1 \cap \bar A_2 \cap \dots \cap \bar A_n|
=& |S|- \sum_{i=1}^n |A_i| + \sum_{1\leqslant i<j \leqslant n}|A_i \cap A_j| - \\
& \sum_{1\leqslant i < j < k \leqslant n} |A_i \cap A_j \cap A_k|+ \dots + (-1)^n |A_1 \cap A_2 \cap \dots \cap A_n|

\end{align}
$$
推论：至少具有一条性质的元素数，可由$|S|$减去上式得到。

对于给定正整数$n=p_1^{\alpha1}p_2^{\alpha2}\dots p_k^{\alpha k}$，求欧拉函数$\phi$的值：

令$A_i=\{x|0\leqslant x < n-1 且 p_i|x\}$，则有$\phi (n) = |\bar A_1 \cap \bar A_2 \cap \dots \cap \bar A_n|$
$$
\begin{align}
\phi(n) &= |\bar A_1 \cap \bar A_2 \cap \dots \cap \bar A_n| \\
&= n-(\frac n {p_1} + \frac n {p_2} + \dots + \frac n {p_k}) + (\frac n {p_1p_2}\frac n {p_2p_3} \dots +\frac n {p_{k-1}p_k}) - \dots + (-1)^k \frac n {p_1p_2\dots p_k} \\
&=n(1-\frac 1 {p_1})(1-\frac 1 {p_2})\dots (1-\frac 1 {p_n})

\end{align}
$$

## 集合恒等式

集合运算满足幂等律，结合律，交换律，分配律，同一律，零律，排中律，矛盾律，吸收律，德摩根律，双重否定律。

## 公理化集合论[^1]

朴素集合论是德国数学家康托尔最早创立的第一个集合论。

朴素集合论中假设任何一个性质都可以用来建构集合，不受任何限制，此一假设就造成了悖论，一个常见的悖论是罗素悖论： 没有一个集合是由“所有不包括自身的集合”所组成的。

公理化集合论只使用可以从明确定义的公理列表证明的关于集合和成员关系的事实。公理起源自我们对对象的搜集和它们的成员的理解，但为了各种目的而被仔细的构架，包括但不限于避免已知的悖论。

### 罗素悖论

罗素悖论$\neq$理发师悖论

> 理发师悖论：有一个这样的理发师，他只给那些不给自己理发的人理发，那么问题来了，他给不给自己理发。

对于理发师问题可以视为一个归谬论证，这样一来问题是得到了解决的，即最终的结论不是理不理发，而是这样的理发师根本不存在。

但对于罗素悖论“所有不是自身元素的集合构成的集合”，即$S=\{x|x \notin x\}$，素朴集合论有一条概括规则允许了该集合S的存在

> 对于任何一个合理的性质P，都存在一个集合来刻画它，这个集合由所有满足P的对象构成。
>
> 合理的，指的是外延明确的，也就是我随便找一个东西一定可以判断它有还是没有这个性质，不会出现既有这个性质又没有这个性质的情况，也就是任意a，要么$P(a)$要么$\neg P(a)$。

对于罗素悖论，$P$是合理的，那么根据概括规则$S$应该存在，而归谬论证可以证明这样的集合$S$不存在，导致了罗素悖论。

理发师悖论是罗素悖论的一个“步骤”，最终的根源——概括规则的矛盾性，才最终导致了素朴集合论的崩溃。

### ZF和ZFC

> mathematicians have occasionally stumbled across holes: statements that can be neither proved nor refuted with the nine axioms, collectively called “ZFC,” that serve as the fundamental laws of mathematics.[^2]

用归谬论证S不存在是不需要依靠集合论的（永真），素朴集合论推出的逻辑矛盾不可调和，最后的选择只能是放弃素朴集合论，或者说修改。

新的集合论的本身也应该能推出“S不存在”，或者说是把$S=\{ x |x \notin x\}$这样的集合从集合这个家族中除名，而不是像素朴集合论那样能推出“S存在”。

ZF系统是一个纯粹的公理系统，它的公理模式规定了集合的一些性质，以及如何从已有的集合产生新的集合。

ZFC（不包含选择公理时为ZF）有如下公理：

[外延公理](https://baike.baidu.com/item/外延公理)、[对偶公理](https://baike.baidu.com/item/对偶公理)、[空集公理](https://baike.baidu.com/item/空集公理)、[子集公理](https://baike.baidu.com/item/子集公理)、[并集公理](https://baike.baidu.com/item/并集公理)、[幂集公理](https://baike.baidu.com/item/幂集公理)、[无穷性公理](https://baike.baidu.com/item/无穷性公理)、[选择公理](https://baike.baidu.com/item/选择公理)、[替换公理](https://baike.baidu.com/item/替换公理)和[正则公理](https://baike.baidu.com/item/正则公理)

> 分离公理模式（可以由替换公理模式和空集公理证明）：对于任意集合X和任意合理性质P，都可以产生出一个集合Y，Y由X中那些满足P的元素构成。
>
> 正则公理：对任意非空集合X，至少有一 $y\in X$使$y \cap X$为空集。

ZF公理系统消除了问题（而不是解决了问题）。

* 区分class和set

$S=\{ x | x \notin x\}$或更一般的$\{x|P(x)\}$只能算class，而不保证是set

#### 选择公理

选择公理会导致巴拿赫-塔斯基悖论



### 罗素的解决方案——类型论

这句话之所以成为悖论，是因为它描述的对象正好是它本身，它在试图谈论自己本身的性质。

理发师悖论也来源于这种自指，数论系统的自指导致了哥德尔不完全性定理，判定一切图灵机停机的图灵机的自指导致了停机问题，而$S=\{x|x \notin x\}$的自指则导致了罗素悖论。

> 使我们能够避免不合法总体的那个原则可以陈述如下：“凡是牵涉到一个汇集的全体，它本身不能是该汇集的一个分子”......必须使关于总体的陈述不属于这个总体的范围之内。

即分阶，若干n阶集合组成的集合为n+1阶集合，这样对于罗素悖论中的S会发现其不属于任意一阶。

罗素甚至还想完全改造集合论的语言——一阶语言。





> 有了集合论的基石，就可以构造关系、函数的大厦了。

# 二元关系

n元组：记作$<x_1,x_2,\dots ,x_n>$或$(x_1,x_2,\dots ,x_n)$，$n=2$时也称为有序对或二元组。

笛卡尔积：$D_1\times D_2 \times \dots \times D_n=\{(d_1,d_2,\dots,d_n)|d_i \in D_i , i=1,2,\dots,n\}$

关系：$D_1\times D_2 \times \dots \times D_n$的子集叫做域$D_1,D_2,\dots ,D_n$上的关系。$n=2$时，称为二元关系。

> 某种程度上可以理解为，关系是一个集合，单个n元组是“关系”的元素，笛卡尔积是“关系”的全集U。



全域关系$E_A=\{<x,y>|x\in A \and y \in A\}=A \times A$

恒等关系$I_A=\{<x,x>|x\in A\}$

> 从符号也能隐约感受到关系和矩阵的联系。



## 关系的运算和性质

关系的运算基本能完美地转换为布尔矩阵的运算。



这里的关系R都是指特定集合A上的关系。即对应到矩阵中都为方阵。

自反性在矩阵上表现就是主对角线上的元素$a_{ii}$都为1；反自反同理，主对角线上元素都为0。

对称性在矩阵上的表现就是对称矩阵，反对称同理。

传递性在矩阵上表现为$R = R + R^2 + R^3 + \dots + R^n$



## 关系的闭包

R是A上的关系，我们希望R具有某些性质，如自反、对称或传递。

* R不具有某性质
* 在R中添加尽可能少的有序对，得到关系R'
* R'具有该性质

称R'为R的该性质闭包。

## 等价关系与划分



## 偏序关系

妈的，凭借着模糊的印象在《离散》图论部分找了半天没找到偏序，终于回过神来在关系部分找到了。

> 自反+反对称+传递

对于传统的主机计算，一个计算任务的顺序只要不违背拓扑排序即可。

对于分布式计算平台，需要通过分布式运算来提高计算速度，但部分计算步骤是串行的、依赖的，不能乱分布，需要通过拓扑排序等方法找到最优的调度方案。



### 全序关系

R为偏序关系，且$\forall x,y\in A$，x，y都是可比的，则称R为全序关系。



### 哈斯图

略



### 实际应用——调度问题

给定有穷的任务集T和m台相同的机器，T上存在偏序关系（即计算步骤之间有依赖）

1. $l(t)$：完成子任务t所需时间
2. $\sigma(t)$：开始时间，$d(t)$：截止时间（一般为无穷）
3. $\sigma:T\rightarrow\{0,1,\dots\}$表示对任务集$T$的一个调度方案
4. $D=max\{\sigma(t)+l(t)\}$

$\sigma$需满足下述三个条件，则为可行调度。



这可不就是分布式计算要解决问题嘛。

但很难说怎样才是最优的调度方案，计算步骤之间的依赖如何处理。



一般性的调度问题，目前还没有找到好的算法。若只有一台机器，截止时间没有限制则只需要拓扑排序即可得到方案。



都说Tensorflow是被误认为深度学习框架的计算流图框架。



# 函数和映射

## 从二元关系到函数

* $F$为二元关系
* $\forall x \in domF$都存在唯一的$y \in \mathrm{ran} F$使得$xFy$成立

则称$F$为函数（映射）。对于二元关系$xFy$，可记作$y=F(x)$

> 若一个二元关系是函数，则其对应的布尔矩阵每一行有且只有一位不为零。
>
> 若该函数还存在逆函数，则其对应的布尔矩阵每一列有且只有一位不为零。
>
> 当然，矩阵认知仅适用于可数集合上的二元关系。





# 同态和同构







[^1]:据说罗素悖论有解，如何解？ - LLLBK的回答 - 知乎 https://www.zhihu.com/question/20511488/answer/133390930
[^2]:[《To Settle Infinity Dispute, a New Law of Logic》](https://www.quantamagazine.org/to-settle-infinity-question-a-new-law-of-mathematics-20131126/) By Natalie Wolchover