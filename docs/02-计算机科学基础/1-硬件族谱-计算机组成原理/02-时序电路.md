# CPU时钟

时钟不是作用在ALU上，而是作用在寄存器上。

> 先复制点题外话[^1]：
>
> 起初，你困惑于时钟。你对自己说： 是不懂数字电路
>
> 然后你会想 产生时钟的振荡电路 是什么原理。你觉得不踏实，你对自己说：嗯，应该去学一下模电。
>
> 然后你会想 NPN PNP 是什么原理，为什么能造出三极管什么的。你觉得不踏实，你对自己说：嗯，应该去学量子力学，物理知识。
>
> 然后你进入量子力学的世界，你发现数学能力捉急，之前理解的世界都是实数，没有维度概念，你觉得不踏实。你对自己说：嗯，应该增加数学修养。
>
> 然后你进入数学的世界，打好数学基础，然后苦恼于为何1+1=2 为何概率和等于1 久久不能释怀，你觉得不踏实。 你对自己说：嗯，应该进一步思考数学的本源。
>
> 然后你进入更高级的数学世界，思考公理化，然后苦恼于天分有限，已经一把年纪了。
>
> 这个时候你身边会你之前非常不屑的摆弄php js的小伙伴们已经搞起了自己的startup 拿到了风投 拥抱白富美走向人生巅峰了。
>
> 都是时钟惹的祸

> 对软工狗的建议[^2]：
>
> 对于数电，你只需要知道组合逻辑就是玩与或非、时序逻辑在玩触发器触发器，了解触发器和与或非是啥。然后记住，时序电路必须有时钟才能工作。
>
> 对于模电，你只需知道数字电路的元件都是用模拟电路设计出来的，高电平1，低电平0。晶振利用晶体的压电效应产生交流电，就是01交替的时钟信号供那些时序电路使用。
>
> 至此您就明白了晶体产生时钟信号，驱动时序电路，和组合电路一同构成CPU，它可以执行特定的指令，即运行软件。OK。再往下，就是电子元件和物理知识。这一切建立在经典电磁学和量子物理学的基础上。

其实吧，作为一个分流大数据方向的软工狗，时钟对我还是有很多思考意义的。在分布式处理中最典型的一个问题就是没有中央时钟，很难判断两个异地任务的先后顺序。

以下正文：

## 晶振

如果硬要追根溯源，大概可以追究到晶振（作为工科再往下就过分了）。

晶振的物理基础是固有谐振频率，化学基础是压电效应。

压电效应，是由各向异性的电介质晶体，比如石英，受到外力作用而出现电介质极化并产生电压的一种非线性力学现象，或者与之相对的，向晶体上加电压而产生的力学现象。

在电气上它可以等效成一个电容和一个电阻并联再串联一个电容的二端网络



## 时序电路

硬件电路有两种，组合电路和时序电路，只有时序电路有记忆功能，也只有这样……

而时序电路的实现，需要时钟进行统一协调

> 从某种程度上来说，时序电路算是有限状态自动机？
>
> 所以时钟频率就是自动机的转换频率？



## 上升沿和下降沿

不同的元器件形成的数字电路，电压对应的逻辑电平也不同。在TTL门电路中，把大于3.5伏的电压规定为逻辑高电平，用数字1表示；把电压小于0.3伏的电压规定为逻辑低电平，用数字0表示。

数字电平从0变为1 的那一瞬间叫作上升沿 ，从1到0的那一瞬间叫作下降沿





## CPU时间周期层级

* 时钟周期
* 机器周期
  * CPU执行一个基本动作所需要的最小时间
* 指令周期



对于外部中断，CPU在执行当前指令的最后一个时钟周期去查询INTR引脚，若查询到中断请求信号有效，同时在系统开中断（即IF=1）的情 况下，CPU向发出中断请求的外设回送一个低电平有效的中断应答信号，作为对中断请求INTR的应答，系统自动进入中断响应周期（即中断响应指令的指令周期）。[^3]

检查中断引脚对CPU来说也是由一个特定的组合电路模块完成。该模块属于流水线的一部分，处在整个电路的末端。

# CPU的记忆：寄存器

也是图灵机的纸带。

## 最原始暴力的编程

有了ALU，我们已经能够进行简单的四则运算了，但是具体的某个电路似乎只能执行某个特定的算术逻辑，比如对于如下算式：

```
(A + B) * 2
```

我们需要设计如下一个电路：



那如果变成了下式

```text
(A * 2) + B
```

那该怎么办呢？再造一个电路吗？

答案就是编程——改加法器模块和位移模块的接线（如图），改成输入A先过位移模块，再进加法器。

![](C:/Users/Five/Desktop/note/img/1-07.jpg)

虽然妹子很好看，但插线属实太繁琐了，能不能让Computer明白我们的意思自己做出调整呢？当然可以。

> 冯·诺依曼《关于EDVAC的报告草案》：
>
> ENIAC的开关定位和转插线只不过代表着一些数字信息，完全可以像程序管理的数据一样，存放于主存储器中。

具体的实现便是多选器。



## 多选器

![image-20201006191709581](C:/Users/Five/Desktop/note/img/image-20201006191709581.png)

如上图所示，当多选器为输入为00时，会最终输出第一个与运算模块的计算结果；当多选器的输入为01时，就会选择输出第二个或运算模块的计算结果。

若有更多的模块，则可以引入更多bit，用n个bit控制$2^n$个输入的选择。

![](C:/Users/Five/Desktop/note/img/1-10.jpg)



通过选择器可以设计激活针脚，这个激活针脚输入1则激活这个模块，输入0则不激活。

这样我们就能通过指令控制数据流入哪个模块，而不是通过繁琐的插线了。



> 当然，我们还漏了一个重要的问题，计算机每次进行算数运算的中间结果该怎么被保存呢？
>
> 我们知道，算数运算的本质是逻辑电路，而逻辑电路的输入输出是高低电平（代表1和0），那这些高低电平从哪里来？又到哪里去（被保存）？我们打开自己的PC的时候可不会去手调电路吧？

## 寄存器

### 原理：触发器

![](C:/Users/Five/Desktop/note/img/1-08.jpg)

上图所示结构即为触发器，**触发器能够存储1bit的信息！**

> 话说高中的时候通用技术课还学过这个电路，当时就觉得这玩意整这么复杂有P用，花里胡哨的。哎，真香。

两个与非门+两个非门构成。即如下逻辑
$$
Q = \overline{\bar{S}\and \bar{Q}} = \bar{\bar{S}} \or \bar{\bar Q} = S \or Q
$$

$$
\bar{Q} = \overline{\bar{R}\and Q} = \bar{\bar{R}} \or \bar Q = R \or \bar Q
$$

S是Set，即给S通入高电平，则$\bar S=0$ ，通过与非门（与门有0则0，与非门有0则1）触发Q，使之为1。

R是Reset，即Q为1时，R通高电平过非门后为$\bar{R}=0$，会使与非门输入$(1,1)\rightarrow(1,0)$，进而触发$\bar{Q}=1$，此时$S=0,\bar{S}=1$，与非门输入$(1,1)$，Q输出为0。

Q即为存储的那个比特。当S和R均没有通高电平时Q的状态不会改变。



### 真实的寄存器工作过程

![image-20201006190414612](C:/Users/Five/Desktop/note/img/image-20201006190414612.png)

![image-20201006190513455](C:/Users/Five/Desktop/note/img/image-20201006190513455.png)

![image-20201006191026791](C:/Users/Five/Desktop/note/img/image-20201006191026791.png)

至此，数据就能被保存在CPU中了。



## 设计一个自己的小CPU

![image-20201006191849297](C:/Users/Five/Desktop/note/img/image-20201006191849297.png)

* 硬件设计

8个输入针脚，其中4位指令，4位数据。

* 软件设计——三个指令
  * 0100，数据读入寄存器
  * 0001，数据与寄存器相加，结果保存到寄存器
  * 0010，寄存器数据向左位移一位，即乘2

让指令输入的第二、第三、第四个针脚分别连接寄存器、位移模块和加法模块的激活针脚。

（此时输入指令的利用率是不是太低了点，每一bit只能对应一个模块，而不是每个数对应一个模块）



> CPU为什么能看懂这些二进制数？

因为CPU内部的线就是这么接的，输入的二进制数像开关一样激活若干对应的模块&改变这些模块的连通方式。



> CPU里面可能有成千上万个小模块，一个32位/64位的指令能控制那么多吗？

我们举例子的CPU里面只有3个模块，就直接接了。真正的CPU里会有一个解码器（decoder），把指令翻译成需要的形式。



> 输入指令0011会怎么样？

当然是同时激活了加法器和位移器从而产生不可预料的后果，简单的说因为你使用了没有设计的指令，所以后果自负呗。（在真正的CPU上这么干大概率就是崩溃呗，当然肯定会有各种保护性的设计，死也就死当前进程）



> 【0001，数据与寄存器相加，结果保存到寄存器】
>
> 这个一步实际上做不出来，毕竟还有一个回写的过程。我们设计的简易CPU执行一个指令差不多得三步，读取指令，执行指令，写寄存器。
>
> 经典的RISC设计则是分5步：读取指令(IF)，解码指令(ID)，执行指令(EX)，内存操作(MEM)，写寄存器(WB)。
>
> 平常用的x86的CPU有的指令可能要分将近20个步骤。



```text
0100 0001 ;寄存器存入1
0001 0100 ;寄存器的数字加4
0010 0000 ;乘2
0001 0011 ;再加三
```



[^1]: https://www.zhihu.com/question/53019975/answer/133207084
[^2]: https://www.zhihu.com/question/53019975
[^3]:https://www.cnblogs.com/niuyourou/p/11907858.html