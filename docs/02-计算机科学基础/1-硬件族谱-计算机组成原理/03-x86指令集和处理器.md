# ISA概述

ISA，Instruction Set Architecture，指令集架构。主要有：

* 复杂指令集运算（Complex Instruction Set Computing，CISC）
* 精简指令集运算（Reduced Instruction Set Computing，RISC） 
* 超长指令字指令集运算（VLIW）
* 显式并行指令集运算（Explicitly Parallel Instruction Computing，EPIC）
  * EPIC体系结构是从VLIW中衍生出来的。

![image-20210326171307607](C:\Users\Five\Desktop\note\img\image-20210326171307607.png)



## CISC

* 1978年6月8日，Intel发布8086，同时带来x86指令集IA-16

  * 1985年，Intel推出的80386微处理器中首先采用IA-32

  * 2001年，Intel推出IA64，又称英特尔安腾架构
    * 没有向下兼容，且采用EPIC架构。

* 2000-2001年，AMD陆续完善AMD64
* AMD64向下兼容IA-32
  
* 2004年，Intel认栽，推出了自己的64位版x86，即EM64T/x86_64

  * 也就是AMD64

> HP拉着Intel试图开发不兼容IA-32/x86_32的全新体系IA-64，而AMD在IA-32的基础上，开发了兼容IA-32的AMD64。
>
> Intel被微软一顿忽悠，说好了会基于IA-64重新开发操作系统，结果就硬鸽，只有基于AMD64的windows操作系统。
>
> IA-64，卒。Intel也不甘心地转向AMD64（交叉授权），但总不能叫这个名呀，多糟心，那就叫x86-64，在代码里变量名不能用'-'，遂习惯用x86_64。
>
> Wintel友谊的小船说翻就翻。
>
> 当然都说还有IA-64的EPIC的锅——不太懂，不赘述了。

> 再后来，为了方便，又把AMD64、x86_64的AMD, x86等前缀变成了x，统称为x64，所以一般下载软件时的x86指的是x86_32（也就是IA32，32位），x64指的是AMD64、x86_64等一系列（即64位）。

## RISC





# IA-16和x86的粉墨登场

毫无疑问，x86是商业上最为成功、影响力最大的指令集架构之一。

![image-20201002153429076](C:/Users/Five/Desktop/note/img/1-31.png)

x86指令集是一种变长的指令集。

IA-16主要属性如下：

* 内部的通用寄存器为16位
  * 兼容8位数据
* 对外有16根数据线和20根地址线
  * 寻址空间为$2^{20}字节=1M$
* 在实模式下，所有的段都是可以读、写和可执行的。
  * 当然实模式是相对保护模式的说法，此时还没有保护模式，叫实模式也许不太妥当
  * 自然也没有特权级的说法



## 简单的x86指令集示例

* 运算类指令
  * 算术运算和逻辑运算
  * 操作的对象主要是通用寄存器

![image-20201002181828141](C:/Users/Five/Desktop/note/img/1-37.png)

INC指令，只有一个字节，对操作数自增1

> 从INC中看x86的设计思想：
>
> INC这种指令，你说它突兀吗，突兀，毕竟只是加法的一种特例，没有也无伤大雅。但程序中用到的多吗？很多。
>
> 所以x86为程序中常见的情况专门设计指令，更计较存储空间，而不是逻辑和架构简洁。

ADC指令，带进位加法，即会把上一次计算后可能产生的进位带进来。

当进行32位以上运算时，要求低位字节相加，而高位字节再相加时就要考虑低位相加的进位，即CF，这时就要用到ADC指令

> 很显然最低位那段用`add`（别让上一个指令的遗留影响这个指令的执行），其他的用`adc`，最终拼接出结果。



* 传送类指令
  * 从存储器都通用寄存器，从寄存器到I/O接口等
  * 操作对象涉及大部分寄存器

![image-20201002160150951](C:/Users/Five/Desktop/note/img/1-34.png)



对于具体的MOV指令：

> 若直接给出操作数，则操作数会体现在指令编码中，CPU在取值的时候会把40作为指令编码的一部分取回。
>
> 直接给操作数不加[]，地址加[]



> 汇编语言中的中括号[]有点类似于C语言中的指针概念的*运算。
>
> 即加了括号表示给定值是一个指针，需要取它的值，而不是它本身。

![image-20201002162411688](C:/Users/Five/Desktop/note/img/1-35.png)

MOV指令编码：

![image-20201002180726289](C:/Users/Five/Desktop/note/img/1-36.png)

其中，第一条“MOV AX, 10EEH”中，1011代表立即数类型的MOV指令，000代表寄存器编号AX，后两个字节表示立即数10EEH.

第二条中……不好意思，汇编知识储备不足，不太清楚具体细节，先留白，以后如果还能记得再来补充。



* 转移类指令
  * 改变指令执行顺序
  * 操作对象主要是指令指针寄存器和段寄存器

![image-20201002184434197](C:/Users/Five/Desktop/note/img/1-38.png)

![image-20201002184701294](C:/Users/Five/Desktop/note/img/1-39.png)

![image-20201002184813012](C:/Users/Five/Desktop/note/img/1-40.png)



* 控制类指令
  * 暂停处理器、清楚标志位
  * 操作对象主要是标志位

![image-20201002184957302](C:/Users/Five/Desktop/note/img/1-41.png)



## 寻址方式

> 看到有20根地址线，但寄存器只有16位，会稍微有点疑问，地址总线位宽比通用寄存器长，那岂不是要两个寄存器去表示一个地址？

确实。X86有特殊的访问地址生成方式。

用段寄存器的方式（Code/Data/Extra/Stack Segment），与其他寄存器联合生成存储器地址。这样一来16位的机子能访问1MB的内存空间，达到设计要求。

即如下图所示，物理地址 = 段基值<<4 + 偏移量。

![image-20201002150556130](C:/Users/Five/Desktop/note/img/1-29.png)

> 那问题又来了，那怎么知道此时该选择哪个段寄存器呢？

作为操作数的话一般默认DS寄存器（Data Segment不是白叫的），当然可以手动指定，在一条指令中明确指出段寄存器的编号。

而取指自然应该是默认CS寄存器。

```assembly
mov byte [es:0x00],'H'
mov byte [es:0x01],0x0F
```



> tm的用两个16寄存器共同表示一个32位寄存器它不香吗？能少用三个寄存器，寻址空间还直接上升到4G。净整这些花里胡哨的干嘛？
>
> 还是说16位寄存器和32位寄存器之间有什么较难跨越的技术差距？

在知乎上也有一些类似提问（一样钻牛角尖，吾辈不孤），搬运一下其中一个回答[^2]：

工程上以满足用户需求为目标，过度冗余设计在产品中是不可取的。在当时的环境下，这是个合理的选择。



## 8086寄存器模型

（能截图何必手打）

![image-20201002144311484](C:/Users/Five/Desktop/note/img/1-24.png)



关于寄存器的具体描述

* 数据寄存器

![image-20201002144416065](C:/Users/Five/Desktop/note/img/1-25.png)

补充：

SP: Stack Pointer

BP: Base Pointer

SI: Source Index

DI: Destination Index







* IP，Instruction Pointer，指令指针寄存器

![image-20201002145901676](C:/Users/Five/Desktop/note/img/1-28.png)

### SS和SP是出于怎样的考量

Stack Segment和Stack Pointer是一组用于维持一个栈数据结构的寄存器。

可不可以没有SS和SP两个寄存器呢？显然可以啊，当我们在程序中需要用到栈的时候，自己在软件层面实现就是了。



### 标志寄存器

单拎出来写。（也是标志寄存器重要，可能其他的部分都耳熟能详了，标志寄存器露脸较少）

常见的有六个状态标志和三个控制标志。

![image-20201002145515264](C:/Users/Five/Desktop/note/img/1-27.png)





# IA-32和x86-64

> x86-16/32和IA_16/32通常指的是同一个东西，但x86-64和IA-64不是。
>
> IA- 64是原生的纯64位计算处理器，与x86指令不兼容，Intel和惠普联合推行，但把事情想得太简单，最终跌了大跟头

## 80386和IA-32

![](C:/Users/Five/Desktop/note/img/v2-ce5e6840753c0157aa97b1b78df17df0_1440w.jpg)

* 第一款32位微处理器
* 支持32位的算术和逻辑运算，提供32位通用寄存器
* 地址总线32位，4G内存空间
* 改进了保护模式
  * 286架构引入保护模式，允许硬件等级的存储器保护。
  * 即使至今，实模式依旧是所有的x86处理器加电后的启动模式——N年前的代码依旧可在最新的x86架构处理器上运行
* 增加了虚拟8086模式，可以同时模拟多个8086微处理器

> 1978年推出8086，1985年推出80386。

## 8086寄存器模型扩展

* 通用寄存器扩展到32位
* 用于寻址的IP寄存器扩展到32位
* 段寄存器没有扩展，依旧是16位
  * 新增了FS和GS两个段寄存器

![image-20201002152958638](C:/Users/Five/Desktop/note/img/1-30.png)

当然实际的寄存器数量远不止于此。

为了支持前面所述的保护模式，还需要TR、GDTR、IVTR等一系列寄存器。

* GDTR是48位的寄存器，前32位为GDT的线性地址，后16位为GDT的边界。
  * 因为每个描述符8字节，所以一共可以有$2^{16}/8=8192$个描述符
  * 所以在选择子中也是用13个bit作为索引，对应$2^{13}=8192$个描述符

除此之外，还有四个32位的控制寄存器CR0，CR1，CR2，CR3，这几个寄存器中保存全局性和任务无关的机器状态。

* CR0中包含了6个预定义标志
  * **第0位是保护允许位PE(Protedted Enable)，用于启动保护模式，如果PE位置1，则保护模式启动。**
    * 当然，需要提前在实模式下准备好保护模式需要的GDT等内容
  * 第4位是微处理器的扩展类型位ET(Processor Extension Type)，其内保存着处理器扩展类型的信息
    * 如果ET=0，则标识系统使用的是287协处理器
    * 如果ET=1，则表示系统使用的是387浮点协处理器。
  * 第31位是分页允许位，表示芯片上的分页部件是否允许工作
* CR1是未定义的控制寄存器
* CR2是页故障线性地址寄存器，保存最后一次出现页故障的全32位线性地址。
* CR3是页目录基址寄存器，保存页目录表的物理地址。
  * 页目录表总是放在以4K字节为单位的存储器边界上，因此，它的地址的低12位总为0，即使写上非0内容，也不会被理会。

### 标志寄存器也鸟枪换炮



## AMD64/x86-64寄存器模型

* 从EAX到RAX（EBX等同理），低32位用法依旧，低16也是
* 新增了8个64位寄存器，从R8到R15

![image-20201002154730402](C:/Users/Five/Desktop/note/img/1-32.png)









## x86指令编码格式

下图取自《64-ia-32-architectures-software-developer-instruction-set-reference-manual》

![image-20210427183812419](C:\Users\Five\Desktop\note\img\image-20210427183812419.png)

其中，只有opcode是必需的，其他部分视情况而定。

![image-20210430164213987](C:\Users\Five\Desktop\note\img\image-20210430164213987.png)

### Prefix

1个字节，分为四组（Group）。

每条指令最多有四个前缀（每组中取一条）：如使用Group1中的前缀`F2H`，则不能再使用Group1中的其他前缀。

> Legacy prefixes must be placed before REX prefixes.

* Group1
  * LOCK prefix is encoded using `F0H`
    * forces an operation that ensures exclusive use of shared memory in a multiprocessor environment. 
  * repeat prefix is encoded using `F2H`、`F3H`
    * 前者为REPNE/REPNZ（Repeat-Not-Zero），后者为REPE/REPZ
      * 默认寄存器为CX（以及扩展后的ECX/RCX）
    * Use these prefixes only with string and I/O instructions (MOVS, CMPS, SCAS, LODS, STOS, INS, and OUTS).
  * Bound prefix
* Group2
  * Segment override prefixes
    * CS: `2EH`, SS: `36H`, DS: `3EH`, ES: `26H`……
  * Branch hints
    * `2EH`: branch not taken. `3EH`: branch taken
    * Use these prefixes only with conditional branch instructions
* Group3
  * Operand-size override prefix is encoded using `66H`
* Group4
  * Address-size override prefix is encoded using `67H`



### Opcode

Two-byte opcode formats for general-purpose and SIMD instructions consist of one of the following:

* An escape opcode byte 0FH as the primary opcode and a second opcode byte.
* A mandatory prefix (66H, F2H, or F3H), an escape opcode byte, and a second opcode byte (same as previous bullet).

For example, CVTDQ2PD consists of the following sequence: F3 0F E6. The first byte is a mandatory prefix (it is not considered as a repeat prefix).

Three-byte opcode formats for general-purpose and SIMD instructions consist of one of the following:

* An escape opcode byte 0FH as the primary opcode, plus two additional opcode bytes.
* A mandatory prefix (66H, F2H, or F3H), an escape opcode byte, plus two additional opcode bytes (same as previous bullet).

### ModR/M and SIB

addressing-form specifier byte，寻址形式说明符字节。

![image-20210430164952306](C:\Users\Five\Desktop\note\img\image-20210430164952306.png)

The mod field combines with the r/m field to form 32 possible values: eight registers and 24 addressing modes.

剩下的3bit Reg/Opcode域由之前的opcode决定具体起什么样的作用，算是对opcode的补充。

Certain encodings of the ModR/M byte require a second addressing byte (the SIB byte). The base-plus-index and scale-plus-index forms of 32-bit addressing require the SIB byte.

![image-20210430165844752](C:\Users\Five\Desktop\note\img\image-20210430165844752.png)



![image-20210430172849016](C:\Users\Five\Desktop\note\img\image-20210430172849016.png)

![image-20210430172936070](C:\Users\Five\Desktop\note\img\image-20210430172936070.png)

### Displacement and Immediate









![image-20201002191352257](C:/Users/Five/Desktop/note/img/1-45.png)

> x86架构的思想于软件工程的想法似乎正好相反。
>
> x86通过大量的指令，使得大部分实践中用到的操作（哪怕看上去不该是原子操作）都有对应的单独指令（而不需要自己通过组合一堆指令实现）。
>
> 当然可能有一定的方便，代码明显会更短，却也带来指令集和逻辑的复杂性。
>
> 虽然代码更短符合软件工程的想法，但以复杂度为代价是软件工程不能接受的。
>
> 而MIPS，在与x86相反的设计理念下，生根发芽。



# 从ISA到处理器架构

处理器架构是用硬件电路去实现指令集架构。具体用怎样的处理器，怎样设计硬件电路，都可以有不同。

所以是**指令集架构决定了处理器的架构**，即先有指令集架构，后有围绕指令集架构设计的底层硬件和上层软件。

从耦合的角度来讲也应该是上层的软件和底层的硬件都去依赖/耦合指令集架构这一统一规范。而不是让指令集架构向下去耦合硬件。



> Thus, the ISA provides a conceptual layer of abstraction between complier writers, who need only know what instructions are permitted and how they are encoded, and processor designers, who must build machines that execute those instructions.[^1]

汇编语言是用人类看得懂的语言来描述指令集。否则指令集就只是一堆二进制机器码。

不过汇编和机器码一一对应，所以常用汇编表示指令集。





## 处理器架构

### Intel，曾经的神

| 发布时间  | 处理器架构/代号 | 代表处理器       | 制造工艺、位数 | 备注                                                         |
| --------- | --------------- | ---------------- | -------------- | ------------------------------------------------------------ |
| 1972年    | /               | 8088             | /              | 梦开始的地方（不考虑4004、8007等）                           |
| 1982年    | /               | 80286            | /              | 最后一块16位处理器                                           |
| 1993.3.22 | P5              | Pentium          | /              | 不再用80xxx数字命名法了                                      |
| 1995      | P6              | Pentium Pro      | 32位           | 16 KB L1 Cache，256KB L2 Cache                               |
| 1999      | P6              | Pentium Ⅲ        | 0.26微米，32位 | 开始引入无序推测执行                                         |
| 2001      | IA-64           | Itanium安腾      | 64位           | IA-64好像既指指令集架构、又指处理器架构？                    |
| 2003      | Pentium M架构   | Pentium M        |                |                                                              |
| 2005      | Yonah微架构     | Core Duo         |                |                                                              |
| 2006      | Core微架构      | Core 2 Duo       | 65nm           |                                                              |
| 2007      | Penryn          | Penryn家族处理器 | 45nm           |                                                              |
| 2008      | Nelhalem        |                  | 45nm/32nm      | 推出酷睿 i5/i3系列，开始集成内存控制器、PCI-E控制器等北桥功能 |
| 2011      | Snady Bridge    |                  | 32nm/22nm      | 引入AVX，沿用 Core i7/i5/i3的命名方式，还有个Ivy Bridge      |
| 2013      | Haswell         | Intel Core系列   | 22nm           | Intel第四代微处理器架构，第五代为Broadwell                   |
| 2015      | Skylake         | Intel Core系列   | 14nm           | Intel第六代微处理器架构                                      |
|           | Kaby Lake R     | Core i7-8550u    | 14nm？         | 我自己目前用的笔记本的CPU就是i7-8550u                        |
|           | Rocket Lake-S   | 第十一代处理器   |                |                                                              |





### AMD，YES！





## 基于ISA，不止ISA

* DMA
* SRAM高速缓存
* 算术协处理器
* MMX和SIMD技术

## 一个栗子

![](C:/Users/Five/Desktop/note/img/635010afa088183ec34140181e876ef1_1440w.png)

左边的一堆ZMM是向量寄存器。





[^1]:《Computer System: A Programmer's perspective》
[^2]:[CPU的历史疑惑]当初8086cpu为什么不直接设计成32根地址总线呢,弄成20根,用段+偏移的寻址方式不觉得尴尬吗？ - ICer的回答 - 知乎 https://www.zhihu.com/question/23567412/answer/24993834
[^3]:操作系统：实模式到保护模式 - 汪先生的文章 - 知乎 https://zhuanlan.zhihu.com/p/54083337
[^4]:https://www.techbulo.com/708.html
[^5]:https://www.cnblogs.com/chenwb89/p/operating_system_003.html
[^6]:https://stackoverflow.com/questions/36617718/difference-between-dpl-and-rpl-in-x86
[^7]:https://stackoverflow.com/a/57926248/11779173
[^8]:《x86汇编语言：从实模式到保护模式》