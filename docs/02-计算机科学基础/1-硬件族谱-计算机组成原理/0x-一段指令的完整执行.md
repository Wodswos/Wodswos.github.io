* 取指令
* 指令译码
* 执行指令
* 访存取数
* 结果写回



# 历代Intel CPU的架构

Skylake

![image-20210326195702704](C:\Users\Five\Desktop\note\img\image-20210326195702704.png)

Haswell

![image-20210326195803329](C:\Users\Five\Desktop\note\img\image-20210326195803329.png)

Sandy Bridge

![image-20210326195932036](C:\Users\Five\Desktop\note\img\image-20210326195932036.png)

Core

![image-20210326200654264](C:\Users\Five\Desktop\note\img\image-20210326200654264.png)

Nehalem

![image-20210326200822423](C:\Users\Five\Desktop\note\img\image-20210326200822423.png)





# 获取指令

## RISC

RISC的指令是不定长的，怎么知道指令的长度？当然不是说没法确定，毕竟有前缀编码兜底，分肯定还是能分清的。但要1字节1字节试过去吗？先取1字节看看？发现不完整再取2字节？这得花很久吧？

* 说法一

CPU刚开始读取指令时并不知道将会执行什么指令，它将指令地址发到地址总线，然后指令将“逐字节”地通过数据总线传送到CPU中，当CPU读取到指令中的操作码（前几个字节）时，就知道了当前指令的长度。

然后IP自增指令长度，周而复始。

* 说法二（比较可信）

一次性取回128bit（16字节）到指令长度译码器（Instruction Length Decoder，ILD），分解出一条完整的指令，舍弃剩下的部分。

> 随着流水线技术的发展，x86虽然是一个CISC的指令集，但底层有越来越强的RISC的味道。



# 指令译码

## 译码器

* 变量译码
* 码制变换译码器
* 显示译码器



译码是编码的逆过程，通常情况下，译码器的输入是一个n位的二进制数，最多会有$2^n$条输出线