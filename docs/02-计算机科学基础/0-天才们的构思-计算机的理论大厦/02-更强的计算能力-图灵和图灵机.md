> 本节内容基本就靠Google和Wikipedia了，知乎和百度已经不太能搜得到详尽的信息了。

（基本就是Copy/翻译Wikipedia和Stanford Encyclopedia这样子）

# 图灵

有非常正面甚至吹捧的书籍，如Andrew Hodges的《Alan Turing: The Enigma》

也有一些相对客观（也可能算有点偏负面？）的观点，比如[王垠的博客](http://www.yinwang.org/blog-cn/2015/10/18/turing)中对图灵的评价。





## 二战和恩尼格玛机

恩尼格玛是对二战时期纳粹德国使用的一系列相似的转子机械加解密机器的统称，它包括了许多不同的型号，为密码学对称加密算法的流加密。

相较于简单的替换密码，明文中的同一个字母可能会被替换成不同的字母。明文中的一个A可能被替换为B，第二个A可能被替换为C。使得字母频率分析法失效。

如此一来26次操作后会重复轮回，恩格玛机有3个转子，可以使得在$26^3=17576$次之后才会重复。后来又增加到5个。

使用“恩尼格玛”通讯时，发信人首先要调节三个转子的方向（而这个转子的初始方向就是密匙，是收发双方必须预先约定好的），然后依次键入明文，并把显示器上灯泡闪亮的字母依次记下来，最后把记录下的闪亮字母按照顺序用正常的电报方式发送出去。收信方同理。

> 恩尼格玛机这种老古董俺也是半懂不懂，也不打算深究，大概这么个意思



在对恩尼格玛密码机的破解过程中，图灵也有着举足轻重的作用。当然，除了图灵之外，还有许许多多的精英和天才参与其中。

## 学术成果





* 1936年，《On Computable Numbers, with an Application to the Entscheidungsproblem》
* 1950年，《The programmers' handbook for the Manchester electronic computer》、《Computingmachiery and intelligence》、《Can Machines Think》

# 弱化的计算模型

>  Turing machines, first described by [Alan Turing](https://plato.stanford.edu/entries/turing/) in Turing 1936–7, are simple abstract computational devices intended to help investigate the extent and limitations of what can be computed. [^1]

![](C:/Users/Five/Desktop/note/img/Automata_theory.svg)

上图是Wikipedia给出的与Automata theory相关的各个概念的包含关系，我们从Combinational logic开始逐层的深入。

Automata theory is the study of abstract machines and automata, as well as the computational problems that can be solved using them. It is a theory in theoretical computer science. The word automata comes from the Greek word αὐτόματα, which means "self-making".

Automata theory is closely related to formal language theory. 

> 自动化理论和形式化语言就像是硬币的正反面，密不可分。
>
> FSM decrible a small class of language which no memory is needed.
>
> Turing Machines are the mathematical description of a computer and accept a much larger class of languages than FSMs do.

An automaton is a finite representation of a formal language that may be an infinite set. 

## Combinational Logic

Combinational logic, somtimes also referred to as time-independent logic.

Sequential logic has memory(the ouput depends not only on the present input but also on the history of the input) while combinational logic does not.

> 我tm的在学组成原理那part的时候就纠结要不要深究CPU时钟、时序电路，结果这里就又遇到了时序电路和组合逻辑电路。

Combinational logic is used in computer circuits to perform Boolean algebra on input signals and on stored data.

In pratical computer circuits, the ALU is constructed using combinational logic.

> ALU是组合逻辑电路，half adders, full adders, half substractors...自然也都是，decoders和encoders也是组合逻辑电路

Practical design of combinational logic systems may require consideration of the finite time required for practical logical elements to react to changes in their inputs. 

即实际生产过程中还是要考虑组合逻辑电路的时延的。

> 个人理解里，组合逻辑电路就是一个映射关系的物理实现，机械且预定义，不可编程。

如下所示为主析取范式$(A \wedge \neg B \wedge \neg C) \vee (A \wedge B \wedge C)$的真值表，是一个简单的组合逻辑示例。

| *A*  | *B*  | *C*  | Result | [Logical equivalent](https://en.wikipedia.org/wiki/Logical_equivalence) |
| :--: | :--: | :--: | :----: | :----------------------------------------------------------: |
|  F   |  F   |  F   |   F    |             $ \neg A\wedge \neg B\wedge \neg C$              |
|  F   |  F   |  T   |   F    |                $\neg A\wedge \neg B\wedge C$                 |
|  F   |  T   |  F   |   F    |                $ \neg A\wedge B\wedge \neg C$                |
|  F   |  T   |  T   |   F    |                  $ \neg A\wedge B\wedge C$                   |
|  T   |  F   |  F   |   T    |                $ A\wedge \neg B\wedge \neg C$                |
|  T   |  F   |  T   |   F    |                  $ A\wedge \neg B\wedge C$                   |
|  T   |  T   |  F   |   F    |                  $ A\wedge B\wedge \neg C$                   |
|  T   |  T   |  T   |   T    |                     $ A\wedge B\wedge C$                     |



## Finite-state machine

有限状态机有很多别称，finite-state automaton有限状态自动机,，finite automaton有限自动机，最简单的state machine状态机

The finite-state machine has less computational power than some other models of computation such as the Turing machine. 

> This is because an FSM's memory is limited by the number of states it has. 

FSMs are studied in the mroe general field of automata theory.

### Deterministic FSM

经典五元组$(Q,\Sigma,\delta, q_0, F)$

* $Q$：FSM的状态的有限集合
* $\Sigma$：输入符号的有穷集合
* $\delta$：$Q\times \Sigma$到状态集合$Q$的映射，即定义了状态$Q$的状态切换关系
  * 一个state-transition table
  * 从某种程度上，就是Combinational Logic，只不过映射关系更为庞大、复杂
* $q_0$：初始状态，显然$q_0 \in Q$
* $F$：终止状态集合，显然$F\subseteq Q$

> 个人觉得可以理解为一个有向图，其中的顶点组成的集合就是$Q$，输入符号$\Sigma$是顶点之间游走的指令，所有顶点之间的通路关系就是$\delta$。

it is conventional to allow $\delta $ to be a [partial function](https://en.wikipedia.org/wiki/Partial_function), i.e.$ \delta (s,x)$ does not have to be defined for every combination of $ s\in S$ and$ x\in \Sigma $.

即FSM对应的图大可不必是一个完全图，可以有部分节点不连通，甚至在部分点对于部分指令没有对应的操作，当FSM面临这种情况时会报错（announce an error/reject the input）。

Wikipedia用coin-operated turnstile（投币式旋转栅门）举例，虽然我没见过投币式旋转栅门，但可以将投币理解为刷卡

![image-20201103110019173](C:/Users/Five/Desktop/note/img/image-20201103110019173.png)

更common的一个state-transition table示例

![image-20201103110246371](C:/Users/Five/Desktop/note/img/image-20201103110246371.png)

### Non-deterministic FSM

A deterministic finite-state machine can be constructed equivalent to any non-deterministic one.





## Pushdown Automaton

In the theory of computation, a branch of theoretical computer science, a pushdown automaton (PDA) is a type of automaton that employs a stack.

 They are more capable than finite-state machines but less capable than Turing machines. 

计算能力介于图灵机和有限状态机之间。

Deterministic pushdown automata can recognize all deterministic context-free languages while nondeterministic ones can recognize all context-free languages, with the former often used in parser design.



# Turing Machine

## 和FSM的比较

> A finite-state machine has the same computational power as a Turing machine that is restricted such that its head may only perform "read" operations, and always has to move from left to right. 
>
> That is, each formal language accepted by a finite-state machine is accepted by such a kind of restricted Turing machine, and vice versa.

图灵机相较于有限状态自动机有“短暂的”的记忆，FSM是完全没有记忆的，只能读纸带和进行状态转换，而不能写纸带[^3]，就是一个Combinatinal Logic的不断重复和复合。

> Turing Machines describe a much larger class of languages, the class of recursively enumerable languages. Finite state machines describe the class of regular languages.[^3]

总结：有无限内存，不仅可以读而且可以写，可以左右移动读写头



## 数学模型

图灵机几乎（了解不够深入，不确定能不能去掉几乎）能描述任意一种形式语言。

更关键的是，存在元图灵机/通用图灵机（通用计算机），即对于给定的输入（数据）和图灵机模型（类似编写的程序），元图灵机都能给出该输入在该图灵机模型上运行的结果。

* 存储：读写的纸带，也即各种存/Memory，内存、硬盘等等
  * 所有可能输入的字符集合$\Gamma$，当前读取的字符$x$，写入的字符$x'$，$x',x\in \Gamma$
* 计算：即控制器+读写头，通常由Combinational Logic实现
  * 转移函数$\delta:Q\times T \rightarrow Q \times T \times \{L,R\}$
    * 字符集$\Gamma$和状态$Q$的笛卡尔积，到状态$Q$的一个映射
  * 初始状态$q_0$，停机接收状态$q_{accept}$，停机拒绝状态$q_{reject}$，显然$q_0,q_{accept},q_{reject} \in Q$
* 





## 计算能力和可判定性



### 停机问题

> 矛盾证明法，类似于$\sqrt 2$是无理数的证明——$\sqrt 2$是有理数会推导出矛盾。

对于一个程序，有没有一个办法判断它是否会终止呢（不陷入死循环）。

不失一般性, 假设我们想要测试的代码是一个函数f。

``` c
void f(char *t);
```


其中t是一个字符串，其指代的是任意输入。判断f对输入t是否会永远运行下去。

遗憾的是，即停机问题不可判定，以下为反证法证明：

假设存在这样的一个函数可用于判断停机问题

```c
bool halts(char *f_code, char *t);
```

其中f_code是我们要进行测试的函数f的ASCII源代码，我们可以认为对f_code进行编译得到了函数f（图灵机）。

当“图灵机”f对输入t停机时, halts(f_code, t)返回true; 当f对t不停机, halts(f_code, t)返回false。

构造这样一个函数

``` c
void modified_halts(char *f_code ) {
  if (halts(f_code, f_code)) {  // 当halts(f_code, f_code)返回true
    while (true) { /*empty*/ }  // 死循环
  }
  else {                        // 当halts(f_code, f_code)返回false
    return;                     // 立即停止运行
 }}
```

即当f对输入f_code停机时，我们让modified_halts不停机；当f对f_code不停机时，modified_halts停机。

假设modified_halts这个函数的编译后的代码是modified_halts_code，如果我们把modified_halts_code作为modified_halts的输入会是什么情况？

 * 如果modified_halts对modified_halts_code停机，说明halts(modified_halts_code, modified_halts_code)返回false，说明modified_halts对modified_halts_code不停机。
 * 如果modified_halts对modified_halts_code不停机，说明halts(modified_halts_code, modified_halts_code)返回true，说明modified_halts对modified_halts_code停机。

综上，矛盾，故得证。

### 接纳问题



### Busy beaver





### 意义

这些不可判定问题，配合哥德尔不完备定理，给了希尔伯特的梦想致命一击。



1. 计算机的计算能力. 随着电子技术和计算机技术的发展, 计算机的存储和计算能力与日俱进, 有些以前看起来不可行的问题现在已经可以轻松地解决. 但是不是当存储和计算能力大到无限的时候, 我们可以解决任何问题? 停机问题给出了否定的答案, 即不管计算机的存储和计算能力有多强, 停机问题都无法解决.
2. 不同语言, 不同计算设备的计算能力. 1936年Alan Turing设计出一种假想的计算设备称为通用图灵机, Church-Turing论题指出如果一个函数是可计算的, 那么这个函数可以用图灵机编程去计算它. 而停机问题就是不可计算的. 虽然现在市面上有很多语言, 看上去C能直接操作底层, C的计算能力要比Java, Python这样的语言更强, 但是现在所有的语言都是Turing完备的, 意思是指这个语言可以被用来模拟一台通用图灵机. 因此, 任何可以用C编程出来的同样也可以用Java, Python这样的语言编程出来, 所有语言在计算能力上等价.
3. 不存在一个完美的工具可以检测代码的运行时性质. 比如说, 许多编译器都可以在编译过程中对代码进行静态类型检查, 以确保代码不会出现运行时的类型错误. 我们同样可以用理发师悖论证明, 不存在完美的类型检查工具, 即一定会存在一些代码, 类型检查工具会认为它有问题, 而实际这个代码不会出现运行时的类型错误. 对停机问题的研究可以作为我们做实际问题的指导.

# 理论扩展和衍生

## 哥德尔和编码

冯诺依曼结构的核心即为将程序作为一种特殊的数据。

但这，哥德尔其实早早就在证明不完备定理的时候就已经运用得炉火纯青了。



## 形式化语言和语义







## 图灵完备

在可计算性理论里，如果一系列操作数据的规则（如指令集、编程语言、细胞自动机）可以用来模拟单带*图灵*机，那么它是*图灵完备*的。

> 什么是图灵完备？ - 知乎 https://www.zhihu.com/question/20115374



# 应用和影响

Automata play a major role in theory of computation, compiler construction, artificial intelligence, parsing and formal verification.

## 从图灵机到冯诺依曼架构



## 编译原理





## 正则匹配

正则匹配的应用内容和编译原理的应用类似。



## 人工智能

### FSM Transducer

![](C:/Users/Five/Desktop/note/img/440px-Fsm_Moore_model_door_control.svg.png)





[^1]:https://plato.stanford.edu/entries/turing-machine/
[^2]:https://en.wikipedia.org/wiki/Bremermann%27s_limit
[^3]:https://cs.stackexchange.com/questions/16315/difference-between-a-turing-machine-and-a-finite-state-machine
[^4]:https://en.wikipedia.org/wiki/Finite-state_machine
[^5]: https://en.wikipedia.org/wiki/Pushdown_automaton

