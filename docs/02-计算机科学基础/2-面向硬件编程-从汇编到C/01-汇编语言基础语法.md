以NASM为主。

# 基本内容

## AT&T vs Intel

* AT&T汇编中的立即操作数前面要加上`$`，寄存器操作数名前要加上百分号`%`，绝对跳转操作数前要加上`*`，Intel的语法均不包含这些符号；
* AT&T语法与Intel语法中使用的源操作数和目的操作数顺序正好相反，AT&T的源操作数和目的操作数是从左到右，Intel语法是从右到左，例如`add eax, 4`在AT&T语法中是`addl $4, %eax`；
* AT&T语法中内存操作数长度由操作码的最后一位字符来确定，Intel语法则通过在内存操作数前使用前缀来达到此目的。
  * AT&T操作码后缀有b/w/l（l取自long word单词的首字母）分别代表内存引用宽度为8位，16位和32位
  * 同理Intel前缀有`byte`、`word`和`dword`
  * 例如Intel中的`mov al, byte ptr foo`对应AT&T中的语句为`movb $foo, %al`；
* AT&T语法中立即跳转和调用为`ljmp/lcall offset`，而Intel中的是`jmp/call far section:offset`，AT&T中的返回指令`lret $stack-adjust`对应Intel的`ret far stack-adjust`；
* AT&T汇编器不支持多代码段程序，类UNIX系统要求所有代码在一个段中；
* AT&T寻址方式：`imm32(basepointer,indexpointer,indexscale)`，Intel寻址方式：`[basepointer + indexpointer*indexscale + imm32)`
  * 如AT&T`movl -4(%ebp),%eax`对应Intel中的`mov eax,[ebp-4]`



## 寄存器

![image-20201002144311484](C:/Users/Five/Desktop/note/img/1-24.png)



* 在8086处理器上，只能够使用BX、SI、DI、BP寄存器提供偏移地址，不能使用其他寄存器
  * BX最初的功能之一就是用来提供数据访问的基地址，B有Base的意思
* 在设计之初，8086每个寄存器就有自己特殊的用途
  * AX是累加器，即A可有Accumulator的含义
  * CX是计数器，即C可有Counter的含义
  * DX是数据寄存器，即D可有Data的含义
  * 至于SI（Source Index）、DI（Destination Index）这些就更是了

### 代码段寄存器

CS不能由`mov`指令直接设置，只能通过改变程序执行顺序的指令（如`CALL`、`JMP`）间接地设置。

​	

# 指令详解

![image-20201016103759002](C:/Users/Five/Desktop/note/img/image-20201016103759002.png)

## 搬运指令

不知道咋称呼，就直接称为搬运。也可以说加载指令，但似乎没有搬运的叫法来得直观、得劲。

```assembly
mov byte [es:0x00],'H'
mov byte [es:0x01],0x0F
mov byte [es:0x02],'e'
mov byte [es:0x03],0x0F
```

* 若没有附加指示，默认段寄存器为DS。
  * 故此处需指明段寄存器为ES。
* 目的操作数需要用方括号围起来，以表明他是一个地址
  * 当然，此处目的操作数也只应该是地址（内存或者寄存器等“容器”），总不会是立即数
* 16位的处理器单次操作的数据宽度可以是8位或16位
  * 上述汇编代码中无法判断源操作数数据宽度（`0x0F`可能代表`0x0000F`）
  * 目的操作数是个内存地址也无法判断数据宽度（就像C语言中你不能根据数组名即指针判断数组长度一样）
  * 故汇编器无法智能判断，需要手动指定数据宽度`byte`
* `mov`指令目的操作数不允许为立即数，目的操作数和源操作数不允许同时为内存单元。
  * 第二点似乎比较霸道，但事实上就算处理器想支持`mov`指令两个操作数均为内存单元，其具体实现的时候也依旧会经过寄存器中转。
  * 因此，不单单是`mov`指令，其他指令也都不支持两个内存单元之间直接进行操作。
    * 直接操作两个内存单元是C语言的抽象层面干的事，而不是汇编这种更底层的语言干的事。

### 批量数据传送

8086处理器提供了`movsb`和`movsw`指令，顾名思义，单位分别为byte和word。

源地址通过DS:SI指定，目标地址通过ES:DI指定，单位（字或字节）数在通用寄存器CX中指定。

还需要制定传送是正向还是反向——即SI和DI随传送过程递增还是递减。CX内容每传送一次递减1。



单纯的`movsw`、`movsb`只能执行一次，如果需要处理器自动反复执行，则要加上前缀`rep`。直到CX为零停止重复。

```assembly
rep movsw
```

标志位DF可指定批量数据传送的方向

![image-20201002191227977](C:/Users/Five/Desktop/note/img/1-44.png)

### 磁盘读写





## 运算指令

* `div`

被除数在AX 或者 AX和DX中（ 注意，后面是AX和DX，AX存放低16位，DX存放高16位）

除数为8位或者16位(即字节型或字型)，在寄存器或内存单元中



当除数为8位时，商存放在AL寄存器中，余数存放在AH寄存器中

当除数为16位时，商在AX中，余数在DX中



## 跳转指令

跳转指令，即`jmp`指令。能主动更改CS:IP寄存器的指令。

一般来说处理器按序实行指令，CS<<4+IP得到物理地址，取得指令执行，同时IP的内容加上当前指令的长度，然后下一个取指、执行、递增IP寄存器的循环，周而复始。

而JMP指令可以无条件转移，可以只修改IP寄存器，也可以同时修改CS和IP。

* `jmp short label`
  * `short`说明进行段内短转移，IP修改范围-128~127，
* `jmp near ptr label`
  * `near`表示进行段内转移，比`short`长，即修改范围约为$\pm 2^{15} $（-32768到+32767）。
    * `jmp short`指令2字节，`jmp near`指令3字节，大概这就是CISC吧，死抠每一丝的资源。
  * `ptr`是pointer的缩写，用来临时指定类型
* `jmp far ptr`
  * `far`实现段间转移，同时修改CS和IP寄存器
  * 最终的机器码形如`EA0880860B`，其中EA是指令，前4位`0880`是IP寄存器要改的值（不再是相对偏移），后四位`860B`是CS寄存器要改的值
* `jmp ax`
  * 将IP寄存器修改为AX寄存器的值



### loop

```assembly
digit: 
       xor dx,dx
       div si
       mov [bx],dl   ;保存数位
       inc bx 
       loop digit        
      ;显示各个数位
       mov bx,number 
       mov si,4  
       loop digit
```

每次loop会将CX寄存器内容减一。

查看lst文件可知，loop的操作码为E2，一个字节的操作数F7（盲猜相当于一个`jmp short`？）

![image-20210320212351106](C:\Users\Five\Desktop\note\img\image-20210320212351106.png)

### 条件转移指令

条件转移指令一般根据标志位进行判断，而不是计算结果。

为了方便，还有一个`cmp`指令，其效果与`sub`指令相同，但不会保留计算结果，仅仅根据计算的结果设置相应的标志位，从而方便了后续执行条件转移指令。

`cmp`指令会影响到的标志位有CF、OF、SF、ZF、AF、PF（也就是状态标志位，不影响控制标志位）



| 比较结果          | 指令 | 备注                             |
| ----------------- | ---- | -------------------------------- |
| 等于，Equal       | je   | 相减结果为0，即ZF=1              |
| 不等于，Not Equal | jne  |                                  |
| 大于，Greater     | jg   | 大于等于jge，小于jl，小于等于jle |



### call

call ≈ push + jmp + ret

8086处理器支持四种调用方式。

* 相对近调用
  * 被调用的目标过程位于当前代码段内，只需得到偏移地址即可
  * 三字节指令，操作码`0xE8`，后跟16位的操作数
    * 范围-32768~32767字节
  * 如果`call`没有提供任何关键字，默认该指令是近调用
    * 即`call`=`call near`
  * `ret`是近返回指令，处理器从栈中弹出一个字到指令指针寄存器IP中。
* 间接绝对近调用
* 直接绝对远调用
  * `retf`是远返回指令，处理器分别从栈中弹出两个字到指令指针寄存器IP和代码段寄存器CS中
* 16位间接绝对远调用



主程序和子程序之间参数传递的方法也主要有四种

* 寄存器传参
* 变量传参
* 堆栈传参
* 利用call后续区





C语言编译后好像是第一个参数给EDI寄存器，第二个参数给ESI，第三个参数给EDX，然后是ECX、R8D、R9D。再多就是用`pushq`压栈了。

C语言中传参数（3、4、5）给一个函数，其生成的汇编代码如下图所示

![image-20210414154815982](C:\Users\Five\Desktop\note\img\image-20210414154815982.png)

同理，传参数（3、4、5、6、7、8）生成的汇编代码如图所示：

![image-20210414155259731](C:\Users\Five\Desktop\note\img\image-20210414155259731.png)





## 其他

### 标志位操作

* `CLD`，Clear Direction Flag，将方向标志位DF清零
  * DF可指定批量数据传送的方向
  * 相反指令是`std`，将DF置为1。
* ZF，Zero Flag
  * 若计算结果为0，则这一位被置为0（用或非门），否则清除此位
  * 同理`CLZ`和`STZ`
* 其他标志位同理



### 其他保留字

`ptr`是pointer缩写，用于临时指定类型。

当操作数存在寄存器时，一般默认根据寄存器的宽度作为操作数的宽度。

> 还有如`push 1000H`不需要指明操作数宽度，因为push只进行字操作。

当操作数为立即数和内存地址时，往往就需要用到`ptr`显式声明操作数宽度。

放在ptr前面的类型有byte（字节）、word（字）、dword（双字）、qword（四字）、tbyte（十字节）、far（远类型）和near（近类型）

# 指示符和伪指令

指示符（Directive）和伪指令（Pseudo Insturction），好像——是一个意思？

用于对汇编过程进行控制的指令，该类指令并不是可执行指令，没有机器代码，只用于汇编过程中为汇编程序提供汇编信息。



* `EQU`，Equate
  * `label equ immediate_number`
* `ORG`
  * 决定此语句后第一条指令（或数据）的地址，即用于指定该段程序的起始地址
  * 直到下一条ORG指令为止
* `END`
  * 用于指示汇编语言程序段结束，若END放在程序中间，则END后面的语句将不再被汇编。
* `PUBLIC`和`EXTRN`
  * 汇编语言中通过伪指令PUBLIC及EXTRN来解决模块之间的联系。
  * PUBLIC用来说明当前模块中可被其他模块所引用的公共标识符。
  * 在AT&T中相应的directive好像是`global function_name`
    * 对于GNU的汇编器AS而言，Both spellings (`.globl` and `.global`) are accepted, for compatibility with other assemblers.



GNU的AS（AT&T）支持的Directives有`.abort`、`.algin`、`.ascii`、`.byte`、`.comm`、`.data`、`.def`、`.double`、`.eject`、`.else`、`.end`、`.elseif`、`.endef`、`.endfunc`、`.endif`、`.endm`、`.endr`、`.equ`、`.equiv`、`.err`、`.exitm`、`.extern`、`.fail`、`.file`、`.fill`、`.float`、`.func`、`.global`、`.if`、`.include`、`.incbin`、`.int`、`.irp`、`.macro`、`.org`、`.rept`、`.section`、`.short`、`.string`、`.text`、`.title`、`.type`等等等等一大堆

可参考官方文档

http://tigcc.ticalc.org/doc/gnuasm.html

https://sourceware.org/binutils/docs-2.31/as/index.html

## 定义数据

`db`、`dw`、`dd`分别用于定义1 byte、1 word、1 double word的数据。

如下述代码使得编译后的代码内容符合主引导扇区的规范：以`0x55,0xaa`结尾。

```assembly
times 510-($-$$) db 0
db 0x55,0xaa
```

### 更简便的做法

```assembly
message db 'some sentence you want to print'
```

NASM支持这样的做法，由编译器负责把它们拆开，形成一个个单独的字节。定义数据

`db`、`dw`、`dd`分别用于定义1 byte、1 word、1 double word的数据。

如下述代码使得编译后的代码内容符合主引导扇区的规范：以`0x55,0xaa`结尾。

```assembly
times 510-($-$$) db 0
db 0x55,0xaa
```

## 标号

在汇编阶段使用，汇编器根据相关信息计算出相应的绝对地址或相对地址。



### 常量定义

```assembly
constant_name equ 100
```

通过伪指令`equ`使得`constan_name`的值为100，通过这种方法起到避免魔法数字、方便统一修改等作用。

`equ`是伪指令，实际上不占任何汇编地址，也不在运行时占用任何内存位置。仅仅为了方便汇编而存在，事了拂衣去，深藏功与名。



## CFI Directives

CFI，Call Frame Information，是DWARF 2.0（Debugging With Attributed Record Formats）定义的函数栈信息。

`.cfi_` 开头的汇编指示符用来告诉汇编器生成相应的 DWARF 调试信息，主要是和函数有关。`.cfi_startproc` 定义函数开始，`.cfi_endproc` 定义函数结束。

https://sourceware.org/binutils/docs-2.31/as/CFI-directives.html#CFI-directives





# 其他

NASM提供标记`$`，等同于标号，可以看成一个隐藏在当前行行首的标号。



