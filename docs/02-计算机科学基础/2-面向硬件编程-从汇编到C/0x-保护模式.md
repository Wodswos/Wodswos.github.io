保护模式，顾名思义，的确能起到保护的作用。在实模式下，程序可以访问任意的物理地址。[^3][^4]

# 历史的包袱

* 段大小受限	
  * 一个段最多只能64KB
* 不能保证地址隔离
  * 同一个物理地址可以被多个段地址+偏移地址访问
  * 这种越界访问既可能是无意的，也可能是有意（恶意）的，但一般都是不好的
* 程序运行时的地址不确定
  * 程序也不知道自己会被加载到哪，起始地址是啥

知道了痛点，自然就该对症下药了。

> 将 CR0 控制寄存器中的标志位打开即可进入保护模式（当然需要提前准备好保护模式所需要的一些数据，如GDT、GDTR）。

# 基本架构

回顾原有的访问方式，是通过段+偏移地址的方式，既然段寄存器和偏移地址寄存器都已经有了，浪费显然不好，于是继续用着吧。

不过不再继续存放段基址，而是存放段选择子（Selector），通过查表，找到段选择子对应的描述符，描述符内包括真正的段基址。



## 段选择子Selector

![](C:/Users/Five/Desktop/note/img/3e80fc1f6301efc95177a1d2503656ae_1440w.png)

* 段寄存器不再直接存放段基址了，而是存放段选择子（Selector）。
  * 某种程度上段寄存器可以称为选择子寄存器（`CS`中S的含义从Segment变成Selector）
  * 通过段选择子索引段描述符
  * T1标识符为1表示LDT，为0表示GDT
  * 程序的特权级需要高于要访问的段的RPL才能访问

> 如何通过Selector的索引找到对应的Descriptor？二分查找吗？
>
> 实际上好像就是单纯的通过算式 GDT基址（保存在GDTR中） + 索引号 × 8（每个Descriptor 8个字节）找到对应的段描述符内存地址。
>
> （实际的操作系统不确定，至少《x86汇编语言：从实模式到保护模式》这本书里是这样访问的）

## 段描述符Descriptor

![](C:/Users/Five/Desktop/note/img/4b909029486695c4aefe6dce20504555c9b08e81.jpg)

> 段描述符的划分看起来很莫名其妙，段基址、段界限、属性各种七零八落。
>
> 这是兼容80286的后遗症，80286是16位处理器，但也有保护模式，其地址是24位的，允许访问最多16MB内存，尽管没成气候，Intel还是决定兼容了——坑爹的祖传屎山。

段描述符长度64位，保存在GDT或LDT中，主要有段基址、段限长、段属性三个部分

* 段基址就是物理地址
  * 不需要再左移四位，（若无分页）段基址+IP就是物理地址
* 段限长用20位表示，段界限决定了偏移量的最大值
  * 可以是以字节为单位或以4K字节为单位，通过段属性中的G位确定
  * 向下扩展的段，如堆栈段来说， 段界限决定了偏移量的最小值
* 上图中已有属性位的注释，翻译如下：
  * L：64位代码段标志
  * AVL：由操作系统（软件层面）自由管理使用
  * D/B：Default Operation Size
    * 对代码段称为"D"位，对栈段称为"B"位
    * 为兼容16位保护模式（祖传屎山）而生，决定使用IP还是EIP，SP还是ESP
  * DPL：描述符特权级
    * 从高到低0、1、2、3四个特权级
    * 刚进入保护模式时执行的代码具有最高特权级 0（可以看成是从处理器那里继承来的）[^5]
  * G：段界限粒度位
    * G位为0时，段界限以字节为单位，段的扩展范围1B~1MB
    * G位为1时，段界限以4KB为单位，段的扩展范围4KB~4GB
  * P：段存在位
    * 一般来说描述符所指示的段都位于内存中
    * 当内存空间紧张时，有可能只是建立了描述符，对应的内存空间并不存在，此时P位应当清零
  * S：段描述符类型
    * 为0时，表示系统段；为1时，表示代码段或数据段，栈段也是特殊的数据段。
  * Type：段描述符子类型
    * 对数据段而言这四位分别表示XEWA，对代码段而言这四位为XCRA
    * X：eXecutable，W：Writable，R：Readable
    * E：段的扩展方向， C：特权级依从，Conforming
    * A：它所指向的段最近是否被访问过
    * 代码段总是可以执行的，但是，为了防止程序被破坏，它是不能写入的。

![](C:/Users/Five/Desktop/note/img/929457-20161230155710164-891968633.png)



## 全局描述符表GDT

* GDT，Global Descriptor Table，全局描述符表，保护模式下一个重要的数据结构。
  * 对应的还有LDT，Local Descriptor Table
  * 一个处理器对应一个GDT
* 通过GDTR（GDT Register）存储GDT的位置
  * GDTR中存放的是GDT在内存中的基地址和其表长界限
  * 通过LGDT指令将GDT的入口地址装入GDTR
    * 指令格式为`lgdt m48`，即GDTR是一个48位（6字节）的寄存器
    * 低16位是GDT的界限值，高32位是GDT的基地址。
    * 初始状态下，基地址为0x00000000，长度值（界限值）为0xFFFF。

> 索引号13bit，所以一个描述符表最多能包含$2^{13}=8192$个不重复的段选择子，对应8192个段描述符。

## LDT和TSS

为了有效地在任务之间实施隔离，处理器建议每个任务都应当具有自己的描述符表，即局部描述符表LDT（Local Descriptor Table）。

类似GDTR，LDTR用于记录LDT的起始位置和界限，用指令`lldt`加载LDT的32位线性基地址字段和16段界限字段到LDTR。

由于每个进程都有自己的一套程序段、数据段、堆栈段，有了局部描述符表则可以将每个进程的程序段、数据段、堆栈段封装在一起，只要改变LDTR就可以实现对不同进程的段进行访问。



TSS，Task State Segment，任务状态段，对应寄存器TR（Task Register）

在一个多任务的环境中，当任务切换发生时，必需保护旧任务的运行状态，或者说是保护现场，保护的内容包括通用寄存器、段寄存器、栈指针寄存器ESP、指令指针寄存器EIP、状态寄存器EFLAGS等等。

处理器用寄存器TR来指向当前任务的TSS。和GDTR、LDTR一样，TR寄存器在处理器中也只有一个。当任务发生切换的时候，TR寄存器的内容也会跟着指向新任务的TSS。



1. 处理器将当前任务的现场信息保存到当前TR指向的TSS；
2. 载入新任务的TSS地址到寄存器TR
3. 从新任务的TSS中恢复新任务的上一次现场



下图取自《Intel 64 and IA-32 Architecture Software Developer's Manuals》Volume 3 System Programming Guide, Chapter 7 Task Management。

![](C:/Users/Five/Desktop/note/img/20160924135346461.jpg)





# 效率问题

原来访问一个物理内存单元只需段基址<< 4 + 偏移地址就能直达目标地址。

而现在要先访问一次内存，得到物理地址，再访问一次内存，得到相应物理地址的内容，这效率直接减半啊，这样子显然不行。

遇事不决上缓存——描述符高速缓存器。

> 即使是在实模式下，段寄存器的描述符高速缓存器也被用于访问内存，只不过此时仅低20位有效，高12位是全零。[^8]

# 特权级和权限管理[^6][^8]

## 特权指令和特权级

最常见的如对GDT、IDT、TSS、LDT等基本数据结构的操作：`sgdt`、`lgdt`、`sidt`、`lidt`、`str`、`ltr`、`sldt`、`lldt`

除CRX和DRX两组寄存器外基本都是**写需要特权级，读不需要特权级**

实模式并不等于保护模式的特权级0，有些指令无法在实模式下执行。

* HLT：停机指令
* LAR：加载访问权限
* 表中CRX 和DRX表示这两组寄存器的所有操作都需要特权

![](C:/Users/Five/Desktop/note/img/1066037-20200222222313562-7084639.png)

处理器还允许对各个特权级别所能执行的I/O操作进行控制。

> 设备管理也是操作系统的一部分，自然不希望用户程序完全不受约束地访问外设。

下图取自《Intel® 64 and IA-32 Architectures Software Developer’s Manual》Volume 1: Basic Architecture Chapter 3 Basic Execution Enviroment.

![image-20210502162638733](C:\Users\Five\Desktop\note\img\image-20210502162638733.png)

其中12、13位是IOPL，即输入/输出特权级，代表当前任务的I/O特权级别。

指令in、ins、out、outs、cli、sti只有在CPL<= IOPL时才能执行。



### CPL和DPL

* DPL，Decriptor Privilege Level
  * 包含在段描述符中，是对被访问对象的特权级描述
* CPL，Current Privilege Level
  * 在老的官方文档里说An internal processor register records the current privilege level 
  * 对于x86的保护模式而言应该就是16位的代码段选择子寄存器（CS）的末两位[^7]

应该说，这样应该就够了，当需要访问段时，比较CPL和DPL即可判断是否有权访问：

在用户程序的代码段选择子里标记特权级3，而内核的代码段、数据段都在其对应描述符中标记特权级为0，如此一来用户程序任何逾矩的行为（如读取、修改内核数据段）都会被处理器发现、阻止。

> 没有用户程序愿意主动将自己放在特权级3上，但这由不得用户程序的心意。
>
> GDT、LDT、分段、描述符这些东西，都不是用户程序编写时需要考虑的——考虑了也没用，反正也不是用户程序自己能决定的。
>
> 这些都是由操作系统管理的，一般情况下，操作系统自然不会白白给用户程序最高特权级。



## 代码段和代码段

在两个特权级相同的代码段之间控制转移还是比较好处理的，但跨特权级就会带来一系列问题了。

### 依从

* 在段描述符的Type字段有一位C，依从位
  * C=0，该代码段只能供同特权级的程序使用。
  * C=1，该代码段可以从特权级比它低的程序调用并进入

不得不说，依从是一个很奇怪的特性：让低特权级反客为主。低特权级的程序能调用依从的高特权级代码，但高特权级的代码却不能调用依从的低特权级代码。

当执行这段依从的代码时，使用的是调用者的特权级，而不是这段依从的段的DPL，即当前特权级（CPL）不会改变。



### 门

门，Gate。门也是一个描述符，故也称为门描述符。

段描述符用于描述内存段，门描述符则用于描述可执行的代码，比如一段程序、一个例程或者一个任务。

> 门可以安装在GDT或者LGT中，但是不能安装在IDT（中断描述符表）中

* 中断门/陷阱门
* 任务门
* 调用门

调用门用于在不同特权级之间实现受控的程序控制转移，通常仅用于使用特权级保护机制的操作系统中。

在调用门的描述符中，定义了目标过程所在代码段的选择子，以及段内偏移。要想通过调用门进行控制转移，可以使用`jmp far`或者`call far`指令，并把调用门描述符的选择子作为操作数。



## 代码段和数据段

### RPL

RPL，Request Privilege Level，包含在数据段选择子中。

它让程序有需要的时候可以表示一个特权级更低的身份Max(RPL,CPL)而不会失去本身的特权级CPL(CS.RPL)。



比如，低特权级的程序通过调用门得到了高特权级的CPL

* 如果程序利用调用门的例程胡作非为怎么办？
* CPL都是0，那处理器怎么知道这个例程是内核自己执行的还是用户程序调用的？



此时就需要RPL：确保特权代码不会代替应用程序访问一个段，除非应用程序自己拥有访问那个段的权限。

> 可以参考以行政权限为例，国家级为0，省级为1，市级为2，县级为3
>
> * 国家主席，其DPL=0，那么显然是想查阅什么就查阅什么。
> * 如果是县长（低特权级）找省长（高特权级）帮忙打听一件事。
>   * 省长（CPL=1）还真找到了这件事的资料（这件事的DPL=1/2）
>   * 但这件事县长（DPL=3）是不应该有权限知道这件事的——这就很为难了，省长显然不应该如实转述给县长。
>   * 因此省长做这件事的时候，不仅要清楚自己的权限CPL=1，还要清楚这时候他是在帮其他人办事，所以有个RPL=3的限制。

也可以认为RPL有方便程序自降访问权限的考虑。

> 就像Python里open一个文件的时候，你可以自己选择打开方式：r、w、a、r+、w+、a+。显然r的权限很低，r能做的事情a都能做，那为什么还要有r这种访问方式呢？都直接用a不就行了？
>
> 当然是为了安全。
>
> 比如只是为了读取文档，看看里面有没有你想要的内容，而不希望影响到文档内容，r显然是最安全的，否则谁知道你会不会不小心干些傻事，比如把文档内容改了甚至删了，真是哭都没地方哭去。
>
> 而以r的方式打开，即使你真的不小心写了改动文件的代码，也会因为权限不够被阻止。

## 总结



* 要想直接转移到非依从的代码段，要求当前CPL和RPL都等于目标代码段的DPL
* 要想直接转移到依从的代码段，要求当前CPL和RPL大于等于目标代码段的DPL
  * 控制转移后，特权级保持不变，而不会刷新为目标代码段的DPL
* 高特权级别的程序（代码段）可以访问低特权级别的数据段



所以每次访问请求都应该进行以下两种检查来确认权限

* CPL高于或等于DPL
* RPL高于或等于DPL

综合一下，就是检查`max(RPL, CPL) <= DPL`是否成立，成立才有权限进行此次访问。

# 整理回顾

至此，整理一下保护模式下访问内存的方式。





> 后续的MMU和分页机制就放到操作系统部分再详述了。



[^1]: 《Computer System: A Programmer's perspective》
[^2]: [CPU的历史疑惑]当初8086cpu为什么不直接设计成32根地址总线呢,弄成20根,用段+偏移的寻址方式不觉得尴尬吗？ - ICer的回答 - 知乎 https://www.zhihu.com/question/23567412/answer/24993834
[^3]: 操作系统：实模式到保护模式 - 汪先生的文章 - 知乎 https://zhuanlan.zhihu.com/p/54083337
[^4]: https://www.techbulo.com/708.html
[^5]: https://www.cnblogs.com/chenwb89/p/operating_system_003.html
[^6]: https://stackoverflow.com/questions/36617718/difference-between-dpl-and-rpl-in-x86
[^7]: https://stackoverflow.com/a/57926248/11779173
[^8]: 《x86汇编语言：从实模式到保护模式》