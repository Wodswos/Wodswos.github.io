> 计算机是数学家一次失败思考的产物

这大抵也是一句很有名的话了吧。

数学家个人理解是泛指，硬要特指的话代表人物就是希尔伯特，思考指的是形式化、可判定行问题。

> 当然也有观点（甚至可以说是事实），计算机早期的发展并不是完全由理论指导进行的，而是众多工程师自己摸索的结果。
>
> 在其他科学领域也有类似情况：
>
> 如果爱因斯坦从未研究相对论，除了无法使用核能和二战日本投降晚一些，对现在的世界还有什么影响？ - 王清扬的回答 - 知乎 https://www.zhihu.com/question/559742132/answer/2765909162





计算理论其实包括两个主要概念：“可计算性理论”（computability）和“复杂度理论”(complexity）。这两个概念在通常的计算理论书籍（比如 Sipser 的经典教材）里，都是用图灵机来叙述的。[^1]



# 可计算性理论



作为一个软件工程专业的学生，突然面对各种各样的概念和名词：计算模型、图灵机、文法和语言、lambda表达式、递归，的确让人眼花缭乱。

* 什么是计算？
  * 也许还应该问什么是算法？
* 这些名词之间又是怎样错综复杂的关系？

## 什么是计算

对于图灵机模型而言，计算似乎就是在纸带上按照规则写上或擦除某个符号

对于lamda演算而言，似乎就是一次函数映射，类似$y=f(x)$

> 甚至$y=f(x) = x$，也是一种映射——正比例函数嘛。
>
> 这么说信息的传输也是一种计算咯？信息的传输不就正是$y=x$的函数映射关系嘛？

## 什么是算法

> 在20世纪30年代，人们成功地找到了算法的数学定义，而且是多个。这些定义背后地思想各不相同，表达方式也不一样，但令人惊奇的是他们所定义的是同一个函数类。这些定义方式背后的概念有递归函数、λ-演算、图灵机、正规算法等。[^2]

欧几里得的辗转相除法是很经典的程序入门题。





> 利用算法的精确定义，我们可以把可判定问题等同于自然数的一类子集，称为“递归集”；把算法可产生集精确描述为“递归可枚举集”。
>
> 可以证明，一切递归集都是递归可枚举集，但是存在不是递归集的递归可枚举集。[^2]





## 邱奇论题

> 邱奇认为λ-可定义函数就是算法可计算函数的精确数学描述，这一观点被称之为“丘奇论题”。[^2]



# 计算模型的维度

最耳熟能详的三种计算过程：递归、λ演算、图灵机。

除此之外还有标签系统、元胞自动机等等。

> λ演算孕育了编程语言，标签系统在证明不同系统的等价性时非常有用，元胞自动机给出了计算全过程的图形表示



| 模型 | 弱                 | 强             |
| ---- | ------------------ | -------------- |
| 机器 | 有限自动机         | 图灵机         |
| 文法 | 正则文法           | 句构造文法     |
| 函数 | 原始递归函数       | 部分递归函数   |
| 程序 | BlooP              | FlooP          |
| 语言 | 正则表达式         | 递归可枚举语言 |
| 应用 | 模式查找、词法分析 | 计算能力       |

## 机器



## 语言

The Chomsky Hierarchy，乔姆斯基分层

图源知乎的一个回答：会使用语言的猩猩是否证伪了乔姆斯基的语言只有人类会使用语言的论调? - 钮祜禄·甄嬛的回答 - 知乎 https://www.zhihu.com/question/544578210/answer/2598000529

![](C:/Users/Five/Desktop/note/img/v2-ac5c9ace15ad010e6c5cfb08e45a9602_720w.jpg)







人是如何把脑内想表达的思想转化为语言的？ - Articulatum的回答 - 知乎 https://www.zhihu.com/question/263466448/answer/2526226044

## 函数





## 程序





# 复杂度理论



## Big O notation

渐进分析法最常用的表示方法是用于描述函数渐近行为的数学符号，更确切地说，它是用另一个（通常更简单的）函数来描述一个函数数量级的渐近上界。

大O符号是由德国数论学家保罗·巴赫曼（Paul Bachmann）在其1892年的著作《解析数论》（Analytische Zahlentheorie）首先引入的。



* O表示渐进上界
  * 存在常数$C>0,n_0 \geq 0$，使得对所有的$n \geq n_0 $，都有$T(n) \leq C\times f(n)$
* Ω表示渐近下界
* Θ表示渐近的紧的界
  * $T(n) = O(f(n)) =\Omega (f(n))$





## NP=P?







# 编码



## 信息熵和时间复杂度

排序的信息熵是$\log N!\approx N \log N$，巧了，时间复杂度也是。

有序数组的二分查找信息熵是$\log N$，巧了，时间复杂度也是。

两件事情是巧合呢，还是说本来就是彼此之间有因果关系我不知道呢？



当然你可以从编码的角度去说，每一次二分查找，确实得到了1bit信息（将数据的下标用二进制表示，每次二分都能从高到低确定目标数据下标的一位），而排序也是。

那是不是所有的问题都能编码呢？所谓计算就是求这个编码？



# 参考资料

之后大概率以这两个课程为主线：

【【北京大学】理论计算机科学基础（全70讲）】 https://www.bilibili.com/video/BV1m4411p7nS?share_source=copy_web&vd_source=fdf58677088d805254f5089791b6488b

【CMU计算机科学理论(完结)—你值得拥有的数学和计算机课】 https://www.bilibili.com/video/BV1Mu411Z7LJ?share_source=copy_web&vd_source=fdf58677088d805254f5089791b6488b



* 《递归论：算法与随机性基础》
* 《论可计算数：图灵与现代计算的诞生》
  * 和《人人可懂的量子计算》同一作者

* 《数学简史：确定性的消失》
  * https://www.bilibili.com/video/BV1WW411x7BJ  《直观看待不确定性原理：不只是量子现象哦》
* 《Programming languages and lambda calculi》



[^1]:http://www.yinwang.org/blog-cn/2013/07/13/church-turing
[^2]: 《递归论：算法与随机性基础》郝兆宽 杨睿之 杨跃
