> 严格来讲，Shell 和 Bash 指的都不是语言，Shell 是一种程序，Bash 是一种程序的实现。
>

一篇教会你写90%的shell脚本 - 华清远见的文章 - 知乎 https://zhuanlan.zhihu.com/p/264346586

# Shell

Shell 是用户和 Linux 内核之间的接口程序，在提示符下输入的每个命令都由 Shell 先解释然后传给 Linux 内核。

Shell 在你成功地登录进入系统后启动，并始终作为你与系统内核的交互手段直至你退出系统。你系统上的每位用户都有一个缺省的 shell。每个用户的缺省shell在系统里的passwd文件里被指定，该文件的路径是/etc/passwd。键入命令 `vim /etc/passwd`：

![image-20210107102303947](C:\Users\Five\Desktop\note\img\image-20210107102303947.png)

passwd文件里还包含有其他东西：每个人的用户ID号，一个口令加密后的拷贝和用户登录后立即执行的程序。虽然没有严格规定这个程序必须是某个Linux shell，但大多数情况下都如此。

> 为了加强安全性，现在的系统一般都把加密的口令放在另一个文件--shadow中，而passwd中存放口令的部分以一个x字符代替。



## 常用的Shell

最常用的Shell有Bourne Shell（sh）、C Shell（csh）、Korn Shell（ksh）等。

* Bourne Shell在Shell变成方面极为优秀
* C Shell更多地考虑了用户界面的友好性，支持命令补齐等特性
  * 语法和C接近
* Korn Shell集合了C shell 和 Bourne shell 的优点并且和 Bourne shell 完全兼容。



除此以外，许多其他的 shell 程序吸收了这些原来的 shell 程序的优点而成为新的 shell，如tcsh（csh扩展）、Bash（Bourne Again Shell）、Pdksh（Public Domain Korn Shell）。

Bash是大多数Linux 系统的缺省shell。



## Shell详解

一些命令，比如打印当前工作目录命令（pwd），是包含在Linux bash内部的（就像DOS的内部命令）。

其他命令，比如拷贝命令（cp）和移动命令（rm），是存在于文件系统中某个目录下的单独的程序。

而对用户来说，你可能不知道（或者不关心）一个命令是建立在shell内部还是一个单独的程序。



## Shell嵌套

Shell是一种程序，比较特殊的是，在Shell里还能调用/开启新的Shell

下图中以Bash为例，

![image-20210107104927953](C:\Users\Five\Desktop\note\img\image-20210107104927953.png)



# Bash

Bash在Bourne Shell的基础上增加/增强了很多特性。

* 命令补全
* 通配符
* 命令历史记录
* 别名，如`alias goconfig='cd /usr/X11/lib/X11/fvwm/sample-configs'`
  * 可以写入你的.profile文件中，如`alias ll='ls -l'`
  * 还可以借助别名让Linux表现得像DOS（Windows）一样
* 输入输出重定向
* 管道
* 提示符，缺省是`$`，root用户为`#`，可以通过改变`PS1`变量值来改变缺省提示符
  * ![image-20210107113402234](C:\Users\Five\Desktop\note\img\image-20210107113402234.png)
* 作业控制，bash 保持对所有已启动的进程的跟踪，并进行挂起、恢复执行等操作
  * `ctrl-Z`使一个运行的进程挂起
  * `bg`命令使一个被挂起的进程在后台恢复运行，反之 fg 命令使进程在前台恢复运行



> Bash满足POSIX规范。





## More Features

既可以说是小技巧，也可以说是Bash的增强特性。

* 保存自定义配置到Bash的初始化文件`usrdir/.profile`中。
  * bash在每次启动时都读取这个文件，并执行所有包含的命令



![image-20210107115024206](C:\Users\Five\Desktop\note\img\image-20210107115024206.png)



更多常用命令和变量

* export，使变量的值对当前shell的所有子进程都可见 。
* fg，使一个被挂起的进程在前台继续执行。
* PS1：命令行的一级提示符。
* PS2：命令行的二级提示符。
* SECONDS：当前shell开始后所流逝的秒
* OLDPWD：前一个工作目录，配合cd使用，`cd $OLDPWD`。



## 各种符号

* 关于赋值和引号

> 在bash中“空格”是一种很特殊的字符——它是默认的分隔符，比如在bash中`str=this is String`这样的语句会报错，为了避免出错就得使用单引号''和双引号""。
>
> 双引号""内的字符将失去其原有意义，除了\$, `和\\。（dollar符、反引号和反斜杠）
>
> 单引号''内的字符将失去其原有意义，包括\$, `和\\。(单引号最强制，但双引号会更灵活)
>
> 在命令行执行shell时，若某个str或file或command中含有空格时，这个时候往往就需要''或""登场了
>
> 反引号内的字符作为一个单独的命令执行。如果在命令行给字符套上反引号，那么linux会先将反引号内的str作为命令执行一次，然后将返回的结果作为命令再在命令行执行



在shell中变量赋值可以不带引号，但一定要两边紧贴等于号=



* 特殊符号\$和\#

> 在Markdown里\$是表示数学公式的标记，反引号是表示代码的标记，所以不可避免要加大量转义符。
>
> 但转义符这种东西也不知道以后各种格式之间转来转去会不会带来啥问题。

\$()和反引号\`\`都用于命令的替换，但并不是所有Unix都支持\$()

```bash
[root@localhost ~]# echo today is $(date "+%Y-%m-%d")
[root@localhost ~]# echo today is `date "+%Y-%m-%d"`
```



> 一般情况下，\$var与\${var}是没有区别的，但是用\${ }会比较精确的界定变量名称的范围。



> \$和那些特殊字符的组合，通常是与Shell本身相关的一些参数
>
> \$0	Shell本身的文件名
>
> \$1~\$n	添加到shell的各参数值,\$1表示第一个参数...
>
> \$?	Shell上一个运行命令的返回指。0表示正常退出(exit(0))。
>
> \$!	Shell最后运行的后台Process的PID
>
> \$\$	Shell本身的PID（ProcessID，即脚本运行的当前进程ID号）
>
> \$-	Shell默认选项-himBH(interactive,histroyExpand,BraceExapation,Monitor...)，与set命令功能相同
>
> \$@
>
> \$*  所有参数列表
>
> $#  添加到shell的参数个数



* 标准错误和标准输出
* 0-标准输入stdin
  * 1-标准输出stdout
  * 2-标准错误stderr



```bash
nohup command>/dev/null 2>&1 &
```

nohup表示忽略响应hup信息，不挂断地运行命令

&表示在后台运行>/dev/null输出到linux黑洞

> bash_command 1>a 2>&1
>
> bash_command 1>a 2>a 

前者只打开一次文件a，后者会打开文件两次，并导致stdout被stderr覆盖。

&1的含义就可以理解为用标准输出的引用，引用的就是重定向标准输出产生打开的a。

从IO效率上来讲，command 1>a 2>&1比 command 1>a 2>a的效率更高。



## Shell脚本[^2][^3]

* `#!/bin/bash`

`#!`是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。

这样一来可以直接用`./filename.sh`命令执行该脚本（需要该文件有可执行权限，可用`chmod`命令修改文件权限），系统自动选择解释器。

当然也可以自己指定解释器`bash filename.sh`，此时`#!`标注的信息会被忽略。



### 变量

运行shell时，会同时存在三种变量：

* 局部变量：在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。
* 环境变量：所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。
* shell变量：shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行



创建或重新赋值普通变量： `name="your_name" `（=两边不可有空格）

使用变量：`echo $variable_name`或者`echo ${variable_name}`

删除变量：`unset variable`







# CMD和Batch

Linux下是Shell，在Windows有类似的CMD和更强大的PowerShell。



## 常用命令

* `netstat -a`，查看所有端口
* `tasklist`，查看所有进程
* `md`，=Linux下`mkdir`
* `rd`，删除目录
* `dir`，≈Linux下`ls`
* `del`，删除文件
* `cls`，清屏



帮助命令`/?`，例如ping的用法可通过`ping /?`命令得到。



## Batch脚本基础语法[^1][^4]

* `REM`和`::`

batch的注释命令，`REM`后的字符在执行时会回显（解释器知道是注释），`::`不会（解释器压根不认为它是一个有效的命令）。

>  任何以`:`开头的字符行, 在批处理中都被视作标号, 而直接忽略其后的所有内容。
>
> 有效标号：后紧跟一个以字母数字开头的字符串，goto语句可以识别。
>
> 无效标号：后紧跟一个非字母数字的一个特殊符号，goto无法识别的标号，但是可以起到注释作用，所以 :: 常被用作注释符号，其实 :+ 也可起注释作用。

另补充行内注释：`%some comments%`



* `echo`和`@`

`echo off`表示关闭掉整个批处理命令的回显。

`@`放在命令前将关闭该命令回显，无论此时echo是否为打开状态

> 所以通过`@echo off`这样的组合可以屏蔽包括本命令在内的后续命令的回显。

在DOS提示符状态（命令行）用`echo off`可以关闭DOS的提示符：

![image-20210108104832566](C:\Users\Five\Desktop\note\img\image-20210108104832566.png)

> `echo ^G` （通过Ctrl＋G输入^G）可在DOS窗口调用喇叭鸣响，就是那个系统warning经常出现的咚咙咙，还挺好玩。



* PAUSE

会输出"Press any key to continue"/“请按任意键继续”。作为熟练掌握C++ HelloWorld写法的我自然对这串提示符不陌生。

`Echo 其他提示语 & pause > nul`



* `GOTO`和`:`

在批处理中允许以“:XXX”来构建一个标号，然后用GOTO XXX跳转到标号:XXX处，然后执行标号后的命令。



* `find`

`FIND [/V] [/C] [/N] [/I] [/OFF[LINE]] "string" [[drive:][path]filename[ ...]]`，在指定文件中搜索特定字符串

>/V 显示所有未包含指定字符串的行。
>/C 仅显示包含字符串的行数。
>/N 显示行号。
>/I 搜索字符串时忽略大小写。
>/OFF[LINE] 不要跳过具有脱机属性集的文件



更多内容可见参考文献[^4]



### 用于打发无聊的小feature

* `title somestring`

可以把DOS命令行的标题（左上角）改为自定义的字符串，比如自己的名字

* `color`

由两个十六进制数决定，第一个为背景，第二个则为前景。

| 数字1 | 对应背景色 | 数字2 | 对应前景色 |
| ----- | ---------- | ----- | ---------- |
| 0     | 黑色       | 8     | 灰色       |
| 1     | 蓝色       | 9     | 淡蓝色     |
| 2     | 绿色       | A     | 淡绿色     |
| 3     | 湖蓝色     | B     | 淡浅绿色   |
| 4     | 红色       | C     | 淡红色     |
| 5     | 紫色       | D     | 淡紫色     |
| 6     | 黄色       | E     | 淡黄色     |
| 7     | 白色       | F     | 亮白色     |



### 特殊符号和参数

* `%~dp0`：获取当前路径

d为Drive的首字母，p为Path首字母，`cd %~dp0 `进入批处理所在目录



* errorlevel



## 进阶内容

* `mode`配置系统设备





## Batch脚本示例

现有一堆照片，命名格式为0001.jpg，0002.jpg，0003.jpg，…，00020.jpg，……要求在所有文件名前加上A_

```batch
@echo off 
rem 启用"延缓环境变量扩充" 
setlocal EnableDelayedExpansion 
set a=1 
rem 循环当前目录下所有图片的文件名，支持带空格的名称 
for /f "delims=" %%i in ('dir /b *.jpg') do ( 
rem 如果没有相同的文件名，则继续 
if not "%%~ni"=="%~n0" ( 
if !a! LSS 10 (ren "%%i" "A_000!a!.jpg") else ren "%%i" "A_!a!.jpg" 
rem 设置数值型变量a=a+1 
set /a a+=1 
) 
) 
echo 批量重命名完成！ 
pause
```







[^1]:https://www.cnblogs.com/hihtml5/p/9272751.html
[^2]:一篇教会你写90%的shell脚本 - 华清远见的文章 - 知乎 https://zhuanlan.zhihu.com/p/264346586
[^3]:https://www.runoob.com/linux/linux-shell.html
[^4]:https://www.cnblogs.com/hellokitty2/p/11923269.html