当我们谈论软件工程的时候，我们在谈论什么？

甚至，当我们谈论软件的时候，我们在谈论什么？



> 看《软件工程——原理、方法与应用》这种教科书的时候，总是很TM疑惑，概念一堆又一堆，但核心需求和主线却十分模糊，结果好好的工科核心课直接变成文科，这尼玛不是坑爹嘛。

> 本文观点仅代表自己个人对软工的理解。

# 工程和设计

世上没有完美的软件。按需设计，是软工的宿命，或者说，这是每个工科的宿命。

## 设计是什么

以计算机的存储机构为例，如果存在这么一种理想的存储器：

* 访问速度足够快（比寄存器更快）
* 容量足够大（比现有的硬盘更大）
* 制造成本足够低（单位数据比磁带更便宜）
* 断电数据还不会丢失

那么今天已有的多级存储结构就该成为历史的尘埃了，吃力不讨好，会有谁屑一顾呢？一块理想存储器不要太香。

所谓设计，不过是在多种不可兼得的现实需求之间的寻求最佳平衡罢了，存储结构的设计大概就是这几种需求平衡的结果：

* 尽可能低的成本
* 尽可能高的效率
* 尽可能高容错的数据持久化
* 尽可能简单的设计
  * 人的精力和能力有限，为了一丢丢可以忽略不记的效率而进行过分复杂的设计也不合适

还有浮点数的存储也是一种精妙的设计，用尽可能少的**比特数**尽可能**精确**地表示尽可能大的**范围**，也就是在三者之间寻找平衡。



## 地图和自顶向下

> 1971年，N. Wirth发表了“用逐步细化（stepwise refinement）的方法开发程序”一文。Yourdon称赞该文“开创了自顶向下设计的先河”。

虽然俺完全不认识这俩人，但大概想表达的就是这么一个意思。用地图来做一个比喻（Inspired By The [C4 Model](https://c4model.com/)）。

我想大部分人应该都不会对地图app感到陌生。当我们打开的

![image-20210110145731721](C:\Users\Five\Desktop\note\img\image-20210110145731721.png)

然后逐步放大，出现了更详细的信息

![image-20210110145703965](C:\Users\Five\Desktop\note\img\image-20210110145703965.png)

再放大，信息更加详细。

![image-20210110145803657](C:\Users\Five\Desktop\note\img\image-20210110145803657.png)



折腾了很久想把每个街道第三张图的标记详细度，应用到第一张图的尺度。但是失败了……

不过应该不难想想，这样的一张图一定是密密麻麻……哪怕明明很详细，却可能对实际的应用屁用没有。

地图如是，结构化设计亦如是。





## UML和C4 Model



### 面向对象和面向过程

把内容放在工程和设计下的子标题的子标题，某种程度说明了我对OOP和POP的个人理解：他们是不同的设计视角，而他们所表达的内容，可以是一样的。

就像下图Tensorflow1的Logo（Tensorflow2换了Logo，还有一个异曲同工的就是GEB，纠结了一下，还是用这个），T和F是观察的视角不同的结果，他们的目的都是表示那个的积木（软件）。

![](C:\Users\Five\Desktop\note\img\download.jpg)

> 继续匿名DISS《软件工程——原理、方法与应用》（史济民、顾春华、郑红著）。
>
> 第四章，面向对象与UML。劈头盖脸一顿概念输出，然后讲面向对象的优点……？？？？对于工科而言是不是有点本末倒置了？
>
> 工科难道不应该是面向问题的学科嘛，遇到了问题然后重新设计、重新思考，再然后建立新的体系吗？
>
> 你只是想写个hello world，难道也要像微信这种大型app一样去面向对象、甚至面向构件地考虑架构嘛？大可不必吧，让设计去匹配需求才是工科的出发点吧。

> 问：OOP是啥新的东西吗？面向过程和面向对象有实质的区别吗？

私以为：不是啥新的东西，从结果上来看也确实没啥区别。

举个栗子，昨天你打开了京东APP，下单买了一本书；今天你又打开了京东，不过不是买东西，而是查看自己的订单物流。

当然可以OOP，设计一个交易模块，一个物流模块。但POP就不行吗？当然行啊，不就一个简单的分支逻辑嘛，面向过程的方法编程也是分分钟的事情。

随便找个基于OOP编程范式开发的应用，难道它的代码最后不是化为一行行机器码有序地送往CPU去执行的吗？当然是。

可以将面向对象归约到面向过程，那反过来呢？私以为只要你把int、float、char都当成对象（Python确实是这么做的），那么你面向过程写的代码不也是面向对象的嘛。



> 问：把OOP说得那么一无是处，那OOP有必要吗？

私以为：太有必要了。

不过要注意一点，面向对象是面向过程的一种特例、一种简化范式。它不是什么先进的、高级的概念，更不是面向过程Plus版，恰恰相反，与面向过程相比，它降低了编程难度。

OOP减轻了程序员在编程中的负担，使得模块化和代码复用更为清晰简单，从而降低了编程的难度，尤其是大规模编程的难度。

自然而然也提高了编程效率。



> 为啥能提高开发效率、能提升协同能力？



### 面向对象和函数式编程

详见王垠的博客，[《编程的宗派》](http://www.yinwang.org/blog-cn/2015/04/03/paradigms)[^1]

自然已经有了很好的文章，显然我这种菜鸟就没必要自作聪明，重复写一份更差的轮子了。



## 工科人，工科魂

现实有多复杂，工科就有多复杂。

苦海无涯，回头是岸。



# 软件和开发

## 软件是什么

### 计算机是什么

既然是刨根问底，那就直接刨到真正的根——数学。众所周知，计算机是数学家一次思考，即形式化，失败的遗产。

> 数学工作是靠数学证明来完成的，每个证明都得有出发点，因此，整个数学必然要有一些不证自明的出发点，由它们出发来构建整个数学大厦。
>
> 这些出发点就是数学公理——他们足够直观，以至于几乎不可能是错的。比如欧式几何的五大公理（修改第五公理会得到黎曼几何）。
>
> 20世纪初，为克服朴素集合论悖论，构建坚实的数学基础，形式主义者提出了宏伟的“希尔伯特纲领”，哥德尔不完全性定理的发表使得形式主义的整体目标以失败告终。

形式系统简单来说，有三部分：符号、公理、推导规则。公理是由符合组成的公式，形式系统做的事就是从公理出发，根据推理规则，机械地推导一个又一个的公式。

我们老说计算机擅长做重复性、机械的劳动，但实际上，只是我们把“可被形式化描述”的任务理解成了“重复性、机械的劳动”，而“复杂、大量的形式化任务”恰恰是人脑所不擅长、容易厌烦的。



> 鉴于此，对于推荐系统划归为人工智能我一直耿耿于怀。
>
> 推荐系统，无论是从名字还是其实现，形式化和算法的味道实在是太浓了，就是很经典的“计算机行为”，并没有给人“智能”的感受。
>
> 而其他的无论是NLP还是CV，直观感受就不像是很经典的“机械任务”，结果居然还真能做到（虽然还是形式化的算法），就很有人工智能的“质感”和“科幻感”。



具体的关于从形式系统到图灵机，从图灵机到冯诺依曼结构的一系列恩怨情仇就不赘述了。

（主要确实是能力有限，本文的内容已经是在吹牛逼了，再扯图灵机这些自己还没彻底理清的东西就更不靠谱了）



### 软件是什么

那软件是什么？程序 + 数据呗。

> 大部分书上可能会加个文档，但个人认为这不是软件的核心，而更像是一种best practice。

那程序和数据是什么？或者说在计算机中是怎样的存储的？0和1的比特流。（也许应该再加个前提“当程序被载入成为进程时”）



那比特流是什么？为什么有价值？因为比特流可以表示信息。

> 信息和熵的定义很多，众说纷纭，但大致上就那么个意思。

那信息是什么？信息是人们对了解事物随机不定性的消除或减少，是两次不确定性之差。



一路追问到了信息，不妨再回头问问，我们究竟是在用程序做什么事情？个人理解就是处理信息。（如果没记错，这应该是小学信息与技术书上的内容，兜兜转转回到了小学的水平）。

处理信息有没有个数学点的说法？（个人理解）形式系统从公理出发，根据推理规则，机械地推导一个又一个的公式。

处理信息有没有个具象点的说法？有，而且还挺“炫酷”，即对现实世界进行模拟。



那现实世界是怎样的？现实世界到处都是对象，一个杯子，一个人，一座楼。我们显然不能把一个杯子塞进计算机，我们能做的是将提取杯子的属性（即信息）。

> 如此一来，是不是面向对象编程就变得顺理成章了起来。

> 对象的概念对于现实有多深刻呢？好多时候仪式感的来源似乎就是基于对对象概念的认知。
>
> 忒修斯之船也是对什么是对象深刻的拷问。

## 一个实例

> 以我个人的一个开源项目bisheng为例进行展开，也算是对项目bisheng的总结。

### 最开始

在最开始，任务往往是简单的，比如，我想把我的Markdown文档批量渲染成HTML文件。考虑到有Pandoc和PyPandoc这两个工具，事情就更简单了。

1. 遍历目录，找到所有Markdown文件，并暂存到一个列表
2. 从列表中依次取出markdown文件，调用PyPandoc的API进行渲染。

所有代码（Python）加起来也不过十来行，甚至还不配称为一个Software。

* 然后我想将生成的HTML自动上传到我的云服务器，于是又要加入自动上传的代码。
* 我想给自己HTML文件的目录生成一个索引，又要加入相应的代码。
* 我想将前面的索引化为一个目录，并写在每个HTML的文档里，方便文档索引。
* 根据国内相关法律，在网上发布得有ICP许可证和备案号吧，那得再往HTML里加个脚注吧？
* 再加一丢丢小小的基本要求，代码不能写死吧？得让用户可以自由配置参数，比如云服务器的ip、用户名、密码啥的吧？

好家伙，虽然还够不上工程的称谓，但事情确实已经复杂起来了，怎么搞？

> 当诸多简单的形式化过程叠加起来，足以使得任务变得复杂，变得难搞



### 事情开始变得复杂

> 越来越脱离抽象的简单逻辑，越来越靠近具体的现实事件。



> 在实际的开发中，往往有着不成文的江湖规矩：约定 > 配置 > 编码，个人感觉这种规矩也从某种程度上隐含着编程水平和对业务的熟练度。
>
> *	最开始用编码去解决问题是很简单的，但代码很死，功能也很单一；
> *	当开始用“配置”去解决问题的时候，考验的是对整个项目/业务是否有框架性的理解；
> *	而当试着用“约定”去解决问题时，考验的是对整个技术栈的认知和理解。



# 最后，关于软件工程

对于一些东西，在王垠大佬的博客里，可以说已经进行了到位的批判。比如

> 总有人提出一套套的所谓“方法论”或者“原则”，比如 Extreme Programming，Design Patterns，Agile，Pair Programming，Test Driven Development（TDD），DRY principle…… 他们把这些所谓方法论兜售给各个软件公司，鼓吹它们的各种好处，说使用这些方法，就可以用一些平庸的“软件工程师”，制造出高质量低成本的软件。这就跟减肥药的广告一样：不用运动，不用节食，一个星期瘦 20 斤。[^1]

> 你开头还不以为然，觉得这些肤浅的说法能造成什么影响。结果久而久之，这些所谓“方法论”和“原则”成为了整个行业的教条，造成了文化大革命一样的风气。违反这些教条的人，必然被当成菜鸟一样鄙视，当成小学生一样教育，当成反革命一样批斗。就算你技术比这些教条的提出者高不知道多少倍，也无济于事，因为他们已经靠着一张嘴占据了自己的地位。[^1]

> 可世界上就是有这样划算的行当，虽然写不出好的代码，对计算的理解非常肤浅，却可以通过嘴里说说，得到评价别人“代码质量”的权力，占据软件公司的管理层位置。久而久之，别人还以为他们是什么泰斗。你仔细看过提出 Design Pattern 的“四人帮”（GoF），做出过什么有实质价值的东西吗？提出“DRY Principle”的作者，做出过什么吗？再看看 Agile，Pair Programming，TDD 的提出者？他们其实不懂很多编程，写出文章和书来也是极其肤浅。

> 人都想省钱，雇用高质量的程序员不容易，所以很多公司还是上钩了。他们请这些“软件工程专家”来到公司，推行各种各样的方法论。推行所谓的 agile，煞有介事的搞一些 stand-up meeting，scrum 之类形式主义东西，以为这些过家家似的做法就能提高开发质量和效率，结果最后都失败了。这是为什么呢？因为再高明的方法论，也无法代替真正的，精华的计算机科学教育。



> 如果光从字面上讲，程序里确实是有一些“模式”可以发掘的。因为你总是可以借鉴以前的经验，用来构造新的程序。你可以把这种经验叫做“模式”。可是自从《设计模式》（通常叫做 GoF，“Gang of Four”，“四人帮”）这本书在 1994 年发表以来，“设计模式”这个词有了新的，扭曲的含义。它变成了一种教条，带来了公司里程序的严重复杂化以及效率低下。
>
> GoF 借鉴的是一个叫 Christopher Alexander 的建筑师的做法。Alexander 给一些建筑学里的“设计模式”起了名字，试图让建筑师们有一些“共同语言”。可惜的是，Alexander 后来自己都承认，他的实验失败了。因为这些固定的模式，并没能有效地传递精髓的知识，没能让新手成长为出色的建筑师。



[^1]:《编程的宗派》王垠 http://www.yinwang.org/blog-cn/2015/04/03/paradigms
[^2]:《所谓软件工程》王垠 http://www.yinwang.org/blog-cn/2015/06/07/software-engineering
[^3]:《解谜设计模式》王垠http://www.yinwang.org/blog-cn/2013/03/07/design-patterns
