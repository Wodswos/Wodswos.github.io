当外设连接计算机时，如何让计算机及时地响应外界的操作？

当应用程序遇到意想不到的行为（典型的如除数为0）时，该怎么处理？

要给应用程序完全的权限吗？如果给了它干坏事或者干傻事怎么办？

如果不给，该从哪里限制呢？当应用程序确实有一些处理需求但没权限的时候，该怎么办？

# 背景故事

> 不是操作系统单方面去配合硬件做设计的，操作系统的发展也会反过来影响硬件的设计，两者是相互影响、相互成就的。

## 保护模式

> 因为有专门记过保护模式的笔记，此处不重复了。

## 操作系统和计算机硬件的发展史[^4][^3]

IBM（International Business Machine Corporation），Intel，Microsoft，三家巨头可以说一家比一家有名。

基本上这三家的公司的发展史也是桌面端计算机硬件和操作系统的发展史。



### 蓝色巨人的辉煌



回顾一下上世纪七八十年代的波澜壮阔

* 60年代，IBM基本一家独大，八大计算机公司也基本是“蓝色巨人和七个小矮人”。
* 在1964年，IBM推出了划时代的System/360大型计算机
  * 其巨大的影响力也带来了长达数十年的反垄断诉讼
* 1975年，IBM生产的计算机数量是世界其他所有计算机厂家生产的计算机总和的4倍
* 1978年，在这部历史里Intel姗姗来迟，发布8086，拉开了x86时代的序幕
* 1980年，IBM公司选中微软公司为其新PC机编写关键的操作系统软件
  * 随着微软公司的日益壮大，Microsoft与IBM已在许多方面成为竞争对手。
* 1979年，微软开始基于Intel开发操作系统Xenix（Unix的一种个人版本）



从中可以提炼到以下信息（反正我以前没注意到）：

* IBM绝对的霸主地位
* 成熟的操作系统比x86出现得要早。
  * 以前孤陋寡闻，一直潜意识觉得操作系统是x86流行之后的产物。
  * 同时潜意识里把Intel和x86当成计算机硬件（CPU）的代名词，显然8太对



### 小弟翅膀硬了



IBM公司于1983年采用了INTEL公司生产的8088芯片作为计算机的CPU(中央处理器)，生产出了一种个人计算机。由于当时许多软件是基于8088设计的，因此许多硬件生产厂家均采用与INTEL公司生产的8088芯片兼容的CPU。

鉴于IBM公司在此领域的先进地位，因此人们把IBM公司生产的采用INTEL公司生产的芯片作为CPU的计算机为原装机，而除此之外的其他公司生产的计算机则称为 兼容机。



* Intel和微软都是
  * 我还一直以为Wintel之中Intel才是大哥，毕竟芯片听着就比操作系统门槛高一些
    * 中美贸易战、华为芯片问题沸沸扬扬，操作系统相对没那么大热度
    * 当然后续国产操作系统鸿蒙的话题热度也很高



> 可以说，Microsoft和Intel是站在巨人IBM的肩膀上。

> 仅十年前（2011），Google、IBM、MS、Apple这些公司的市值还基本在同一起跑线。
>
> Apple和Google都抓住了移动端的风口，MS错过但也愣是没落下，三家公司纷纷市值过万亿，留下IBM一个人在风中凌乱。
>
> 市场真是无情啊。

## 一些历史遗留问题

### PSW是什么？

关于PSW网上反正是众说纷纭，下面内容是我基于Wikipedia的理解，和一些博文可能有冲突，本身也不一定完全正确。

> **我不要你觉得，我要我觉得**

PSW，Program Status Word，程序状态字，更偏向于是一个**操作系统层面的概念**，协助操作系统描述和管理一个程序。

The Program Status Word or PSW is a collection of data 8 bytes (or 64 bits) long, maintained by the operating system. It keeps track of the current state of the system. 



#### IBM 360 Architecture和PSW

The IBM System/360 (S/360) is a family of mainframe computer systems that was announced by IBM on April 7, 1964, and delivered between 1965 and 1978.

![](C:/Users/Five/Desktop/note/img/IBM_System_360_model_30_profile.agr.jpg)

The IBM System/360 architecture is the model independent architecture for the entire S/360 line of mainframe computers, including but not limited to the instruction set architecture. 

PSW是IBM System/360 architecture中的概念。

一般认为PSW为8个字节，下表为IBM System大致的PSW格式（不同的版本有差异）[^4]

| Bits  |        Contents         |                         Explanation                          |
| :---: | :---------------------: | :----------------------------------------------------------: |
|  0-7  |       System Mask       | bits 0-5: enable channels 0-5, bit 6: enable all remaining channels, bit 7: enable External interruptions (timer, interrupt key, and external signal) |
| 8-11  |     Protection key      | CPU protection key to compare against storage protection keys |
|  12   |       ASCII mode        | enable ASCII mode for packed decimal instructions, never used by IBM software |
|  13   |     Machine checks      |              enable Machine check interruptions              |
|  14   |       Wait State        | processor is halted, an interruption, if enabled, will cause the processor to resume executing instructions |
|  15   |      Problem state      | enable to prevent the use of instructions reserved for supervisor state |
| 16-31 |    Interruption Code    | code to indicate the type of interruption, inserted when the PSW is stored, during IPLoad, this is the address of the device from which the program was loaded |
| 32-33 | Instruction Length Code |           length in halfwords or 0 if unavailable            |
| 34-35 |     Condition Code      |           see individual instructions for encoding           |
| 36-39 |      Program Mask       | bit 36: enable fixed-point overflow, bit 37: decimal overflow, bit 38: exponent underflow, bit 39: significance |
| 40-63 |   Instruction Address   | address of next instruction, except for a program interruptions with ILC 0 |



The 64-bit PSW describes (among other things)

* Interrupt masks
* Privilege states
* Condition code
* Instruction address



> Although certain fields within the PSW may be tested or set by using non-privileged instructions, testing or setting the remaining fields may only be accomplished by using privileged instructions.

#### x86和ELAGS

在x86中，显然很少听到PSW的概念，而变成了标志寄存器FLAGS/ELAGS和段寄存器这些概念。

> 所以在我的理解里，硬件上**并没有一个特定的寄存器表示来存储所谓PSW**，或者说，PSW的不同信息可能会被分散存储在不同的寄存器中。



## 管态和目态

管态=内核态，目态=用户态。

在计算机运行中，内核是被信任的第三方。只有内核可以执行特权指令。

而中断、异常、调用是内核和外界（应用程序/外设）打交道的主要方式。

![image-20201014160620350](C:/Users/Five/Desktop/note/img/image-20201014160620350.png)

三种不同的交互方式有不同的来源、响应方式（中断是异步的，异常是同步的）、处理机制。

* 调用：应用程序主动向操作系统发出的服务请求。
  * 来自应用程序，主动且积极
  * 异步或同步
* 异常：指令执行失败后的处理请求。
  * 来自应用程序（通常是“越界”的、被动的行为）
  * 同步
* 中断：来自硬件设备的处理请求。
  * 来自外设
  * 异步



> 同步Synchronous，调用某个方法/函数（如处理例程）返回后才继续执行。
>
> 异步Asynchronous，在调用某个方法/函数后可以继续执行后续操作，被调用者完成后通知调用者，处理这个调用。
>
> 异步更像是一种消息传递——调用者不是很在乎被调用者处理的结果，而只要调用者收到了处理的消息，他就任务完成了。



> 好像 程序状态字寄存器 = 标志寄存器？8太确定，姑且这么理解吧。



### “陷入”内核



当用户程序欲访问系统资源时（无论是硬件还是内核数据结构），它需要进行系统调用，这样CPU便陷入了内核态，也称管态。[^2]

用户进程陷入内核态后都是在执行内核的代码，引起这种“陷入”的应用程序自身已经不再占有CPU，其上下文被保存起来，而绝不是操作系统给了用户进程特级权限的意思，也不是让用户进程自己在“内核态”执行指令。

> 即所谓陷入内核就是通过中断将CPU交还给操作系统，也就是系统调用。

“陷入”具体是怎样一个过程？





# 中断

来自硬件设备的处理请求。

* 当中断发生时，CPU立即进入核心态
* 当中断发生后，当前运行的进程暂停运行，并由操作系统内核进行处理



中断是从用户态转到核心态的唯一途径，核心态到用户态可以通过执行特权指令，设置PSW（程序状态字）。

## 中断向量/描述符表



## 中断处理机制

### 硬件处理

在CPU初始化时设置中断使能标志。

1. 依据内部或外部事件设置中断标志
2. 依据中断向量调用相应中断服务例程



### 软件处理

1. 现场保存（编译器）
2. 终端服务处理（服务例程）
3. 清除中断标记（服务例程）
4. 现场回复（编译器）



## 系统调用与软中断

中断本身是一个硬件概念，就是打断CPU，让其执行一下其他任务，比如键盘中断、打印机中断、定时器中断等。软中断本就是从软件层面模拟了这一中断操作。

128号软中断指令使进程从用户态陷入内核态，执行完毕后调用iret指令重回用户态。

随着CPU的升级，Linux内核一般会使用快速系统调用的systenter/syscall指令代替。

在运行软中断指令的时候，会用一个寄存器来存储具体的系统调用号，比如在Linux上的read和write的系统调用号分别为0和1。



## 中断嵌套

* 硬件中断服务例程可被打断
  * 不同硬件中断源有不同优先级，可以交替处理
  * 硬件中断服务例程中有临时禁制中断请求的可能
  * 中断请求会保持到CPU做出响应（还真执着）
* 异常服务例程可被打断
  * 异常服务例程执行时可能出现硬件中断
* 异常服务例程可嵌套


## 不同操作系统的中断

BIOS和DOS都是存在于实模式下的程序，由他们建立的中断调用都是建立在中断向量表（Interrupt Vector Table，IVT）中的。都是通过软中断指令int中断号实现的。

# 异常

指令执行失败后的处理请求。



* 保存现场
* 异常处理
  * 杀死产生异常的程序
  * 重新执行异常指令
* 恢复现场





# 系统调用

应用程序主动向操作系统发出的服务请求。

运行在用户态的程序，想使用某些内核态才能执行的功能，必须要经过系统调用来实现。

> 例子：应用程序调用`printf()`

应用程序调用`printf()`时，会触发系统调用`write()`

![image-20201014164038874](C:/Users/Five/Desktop/note/img/image-20201014164038874.png)

* 系统调用是操作系统服务的编程接口
* 通常由高级语言编写（C或者C++）



* 程序访问通常是通过高层次的API接口，而不是直接进行系统调用（如标准C库）
  * Win32 API，用于Windows
  * POSIX API，用于POSIX-based system

[Win32等API文档的PDF](https://docs.microsoft.com/zh-cn/windows-hardware/drivers/)可通过官方下载。



## 系统调用的实现

* 每个系统调用对应一个系统调用号
  * 系统调用接口根据系统调用号来维护表的索引
* 系统调用接口调用内核态和具体功能实现，并返回系统调用的状态和结果



### 微内核与单内核

![](C:/Users/Five/Desktop/note/img/v2-9c63ac94e434ef5cdf6525b8f4663dfe_1440w.jpg)

但就系统调用的实现原理来说单内核和微内核没有差异。

但单内核提供许多服务，以Linux为代表，系统调用十分繁多，有三百多种。

而微内核则没有那么多系统调用，比如MINIX只有三个系统调用——\_send()、\_receive()、收发一体\_sendrec()，而open、read、write、fork等都是通过这三个系统调用实现的。



### uCore系统调用实例

***文件复制过程中的调用序列***

1. 获取输入文件名

2. 获取输出文件名

3. 打开文件

   若不存在，出错退出

4. 创建输出文件

   若文件存在，出错退出

5. 循环

   1. 读取输入文件
   2. 写入输出文件

6. 关闭

7. 正常退出



![image-20201014201051067](C:/Users/Five/Desktop/note/img/image-20201014201051067.png)





## 系统调用的开销

系统调用比函数调用更安全，但有更大的开销——源于用户态的切换：

* 建立（中断/异常/系统调用）号与对应服务历程映射关系的初始化开销
* 建立内核堆栈
* 验证参数
  * 因为操作系统不会也不该信任应用程序
* 内核态映射到用户态的地址空间
* 内核态独立地址空间





### 系统调用和函数调用

* 系统调用
  * INT和IRET指令用于系统调用
  * 有堆栈和特权级的切换
* 函数调用
  * CALL和RET用于常规调用
  * 常规调用时没有堆栈切换

## 关于移植性

> 假如有这个Windows应用程序的源代码比如QQ，要改造成一个Linux应用，会有多大工作量？ - 知乎 https://www.zhihu.com/question/309576803
>
> QQ ？那几乎是重写。
>
> QQ 大量依赖 Windows 下面的技术和功能。这导致几乎只有核心通讯协议的源代码，可以不大改，剩下的部分都要重写修改成 Linux 下面的调用和功能来支持。
>
> 不过要是说 QQ for mac ，这东西改成 Windows 倒是相对容易一些。或者移植 TIM 
>
> 另外，其实很多软件现在都做上下层剥离的开发模式了。软件界面是独立的，软件支持库也是一个中间函数库独立的，应用程序核心功能是不参与系统调用的。
>
> 更有些软件，我要没记错，暴雪的某些东西，是用  QT 写的，QT 直接可以开发跨平台的程序。几乎不用修改。
>
> 另外，有些软件也是借助 mingw 开发的。这种软件注意一下，也可以开发成跨平台不需要修改的程序。不过 mingw 只是一个编译器，调用的函数库更关键，一般都是靠 cygwin 做支撑。在cygwin 编译出来所有需要的函数库一起发布也是个办法。
>
> 作者：jiangtao9999
> 链接：https://www.zhihu.com/question/309576803/answer/577139082
> 来源：知乎
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



> 所以NodeJS，Java，Python相比于C有着更低的门槛（语法简单强大，不需要关心底层），还有可移植性上的优势，越来越受欢迎也就不奇怪了。
>
> 对于损失的那一点点性能——有的是项目不在乎这一点性能，更快的开发和更好的可移植性能带来的经济效益也很明显。
>
> 以经济效益为指标，在开发成本和资源成本之间权衡利弊，两害相较取其轻。

### wine

“Wine is Not an Emulator”

一个能够在多种 POSIX-compliant 操作系统（诸如 Linux，Mac OSX 及 BSD 等）上运行 Windows 应用的兼容层。

> 第一次看到递归缩写是GNU: GNU's Not Unix.









# 题

> 中断处理和子程序调用都需要压栈以保护现场。中断处理一定会保存而子程序调用不需要保存其内容的是（）。

程序状态字寄存器。

PSW用于记录当前处理器的状态和控制指令的执行顺序，并且保留与运行程序相关的各种信息。主要作用是实现程序状态的保护和恢复。

所以中断处理程序要将PSW保存，子程序调用在进程内部执行，不会更改PSW。



> 下列选项中，在用户态执行的是（ ）
>
> * 命令解释程序  √
> * 缺页处理程序
>
> * 进程调度程序
> * 时钟中断处理程序







> 下面对于分时操作系统的说法，正确的是（）
>
> * 应用程序执行的先后顺序是完全随机的
> * 应用程序按照启动的时间依次执行
> * 应用程序可以交替执行  √
> * 应用程序等待的时间越长，下一次调度被选中的概率一定越大



[^1]: 怎样理解阻塞非阻塞与同步异步的区别？ - Yi Lu的回答 - 知乎 https://www.zhihu.com/question/19732473/answer/20851256
[^2]: 《操作系统真象还原》郑刚（PS：我没打错字，作者就是要用“相”的同音字“象”）
[^3]: https://en.wikipedia.org/wiki/Program_status_word
[^4]: https://en.wikipedia.org/wiki/IBM_System/360_architecture
[^5]: 《x86汇编语言：从实模式到保护模式》