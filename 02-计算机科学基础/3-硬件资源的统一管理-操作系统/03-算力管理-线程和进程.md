# 进程

## 批处理系统和作业

进程是操作系统抽象出的一种模型，理论上进程可以调用任意多的计算资源。

作业是一个具体的任务或现实业务，一份作业可能由若干个进程组合进行完成，当然也可以由一个进程完成。

> 最最最简单的，求两个数相加的和，也是一个作业——当然一个进程就够了。复杂一些的，模拟一颗核弹的爆炸参数，也是一个作业，就会复杂很多。

### 作业调度算法

SJF和FCFS是很粗糙也很朴素的调度思路。

* 先来先服务，FCFS，First-Come First-Served。
* 短进程优先，SJF，Short Job First。

从优先级的角度来看，在FCFS中，就是把顺序作为唯一优先级，在SJF中，就是把运行时间作为唯一优先级。



这种朴素粗暴的方法自然会面临很多问题。



于是我们需要一个比顺序或者运行时间更靠谱的指标，而相应比是一个比较理想的选择。
$$
优先权 = \frac {等待时间 + 要求服务时间} {要求服务时间} = 1 + \frac {等待时间} {要求服务时间}
$$



常数1可以忽略，即响应比（优先权）就是等待时间比上要求服务时间。

## 进程的一般构成

进程一般由以下几个部分组成

* 进程控制块（PCB）
* 程序段
* 数据段

### PCB

**PCB是进程存在的唯一标志，系统总是通过PCB对进程进行控制的**

不同的操作系统PCB所包含的内容多少会有些不同，但通常都包括下面所列出的内容。

* 进程标识符（PID）
* 进程当前状态
* 进程队列指针：记录PCB队列中下一个PCB的地址
* 程序和数据地址
* 进程优先级
* CPU现场保护
* 通信信息、家族联系、占有资源清单



## 进程的状态与转换

* 就绪状态
  * 阻塞 vs 就绪：就绪状态已经获得处理器以外所有资源，比如时间片用完，会从执行进入就绪状态
* 执行状态（运行状态）
* 阻塞状态（等待状态）
* 创建状态
* 结束状态



**阻塞与唤醒：**

阻塞原语（P原语）将进程由**执行状态**转为**阻塞状态**。

唤醒原语（V原语）将进程由**阻塞状态**转为**就绪状态**。（唤醒是由**发现者进程**调用，对于阻塞进程是一种被动行为）



## 进程通信



### 高级进程通信方式

* 共享存储器系统
* 消息传递系统
  * 由操作系统提供一组通信命令（隐藏具体的实现细节）
* 管道通信系统
  * 管道是一个共享文件







> Message passing may be either blocking or nonblocking - also known as synchronous and asynchronous.
>
> * Blocking send: The sending process is blocked until the message is received by the receiving process or by the mailbox.
> * Nonblocking send: The sending process sends the message and resumes operation.
> * Blocking receive: The receiver blocks until a message is available.
> * Nonblocking receive: The receiver retrieves either a valid message or a null.
>
> ——《操作系统概念（第九版）》



# 进程的调度

## 进程调度算法评价标准

进程调度的评价标准一般包括：

* CPU利用率
* 系统吞吐量
* 响应时间
* 周转时间
  * 周转时间（从提交到执行完成的时间）、平均周转时间、带权周转时间、平均带权周转时间

## 非抢占式

顾名思义，一旦CPU分配给某进程后，就一直让它运行下去，不会打断，直到进程自己完成或阻塞。

交互性可想而知的差，不适用于分时系统。



非抢占式调度算法有：

* 先来先服务（FCFS）
* 短作业优先调度算法（SJF）





## 抢占式1：优先权原则

即优先级调度算法，这种算法可以是抢占式的，也可以是非抢占式的。

短作业有些可以视为优先级调度的一种特例：优先级的指标简单粗暴地设为时间长短。



## 抢占式2：时间片原则

即轮转调度算法，调度的时机：

* 一个时间片内，运行的进程已经完成，则立刻激活调度
* 时间片用完，计时器中断程序激活，进行调度

时间片的选择：时间片太短，进程切换的消耗会很可观；时间片太长，可能会陷入退化为FCFS算法的窘境，也难以满足交互。



## 综合优化

### 多队列调度算法



### 多级反馈队列调度算法

通过动态调整进程优先级和时间片的大小，多级反馈队列调度算法可兼顾多方面的系统目标。

* 设置多个就绪队列，队列的优先级逐次降低，但相应的时间片逐次增加（通常第 i+1 队列为第 i 队列的两倍）
* 每个队列内部遵守先来先服务原则。
* 仅当前面的队列都空闲时，第 i 个队列中进程才会被调度运行。



1. 一个新进程进入系统后首先进入优先级最高的队列
2. 若进程在所处队列的一个时间片内未执行完成，则进入次一级队列的末尾。



### 基于公平原则的调度算法



# 互斥和同步

## 基本概念



### 临界资源与临界区

同时仅允许一个进程使用的资源称为临界资源。许多物类设备（如打印机）都属于临界资源。



### 互斥的概念和要求

互斥的四大准则：

* 空闲让进
* 忙则等待
* 优先等待
* 让权等待



## 互斥实现

###  软件方法

### 硬件方法

用一条指令完成标志的检查和修改这两个操作，因而保证了检查操作与修改操作不被打断。



## 信号量

信号量是一个确定的二元组 $(s,q)$ ，其中 s 是一个具有非负初值的整型变量，q 是一个初始状态为空的队列。

```c
struct semaphore{
    int count;
    queueType queue;
}
```

P操作：

```c
wait (semaphore s){
    s.count --;
    if(s.count < 0){
        阻塞该进程；
        插入等待队列 s.queue;
    }
}
```

V操作：

```c
signal (semaphore s){
    s.count ++;
    if(s.count <= 0){
        从等待队列 s.queue 中取出第一个进程;
        将该进程插入就绪队列;
    }
}
```

### 信号量分类

* 整型信号量
  * 存在“忙等”现象
* 记录型信号量
  * 添加链表结构，使得进程能够放心自我阻塞，等待唤醒



## 经典同步问题

### 生产者-消费者问题

用三个信号量解决。

需要注意，必须先对资源信号量进行P操作，再对互斥信号量进行P操作，否则会导致死锁。同理可应用到几乎所有关于P、V的问题中，需要先对资源信号量进行P操作，从而可以**保证在占有信号量访问权时有资源可用**，避免死锁。

> 在单生产者和消费者的情况下，互斥信号量不是必需的。但对于多消费者、多生产者的情况，互斥信号量是必须的。

### 读者-写者问题

* 读者优先
* 公平情况
* 写者优先

### 哲学家进餐问题

最简单粗暴的算法可能会面临死锁问题，故有如下可行的解决方案

* 规定最多只能 n - 1 个哲学家同时进餐
* 仅当一个哲学家左右两边的块同时可用时，才可以拿起筷子
* 将哲学家编号，要求奇数哲学家先拿左边筷子，偶数哲学家先拿右边筷子



### 理发师问题



## 管程





## 死锁

### 基本方法

* 鸵鸟算法
* 预防死锁
* 避免死锁
* 检测及解除死锁



### 银行家算法

#### 安全性算法

1. Work = Available; Finish[i] = false;
2. 查找满足 "Finish[i] = False; Needi <= Work"的i，若不存在，跳转至4
3. Work = Work + Allocationi , Finish[i] = true，并返回至2
4. 若最终任意 i 都有 Finish[i] = true 则安全，反之不安全

# 线程管理[^1]

线程这种东西和段机制一样，都是现代计算机科学中比较重要的概念，但又披着厚厚的历史迷雾，随着时间的演变，他还是他，但又不是他了。

作为一个萌新，我一直下意识觉得多线程是伴随多核CPU诞生的产物——其实不然，在单核的年代就早早有了多线程的概念。

在那个年代，多线程的主要目的是为了协调I/O密集型和计算密集型的作业——I/O的时候不闲置CPU。而到了今天，多核CPU才使得线程得到了真正意义上的并行。

> Python存在CLI也是类似的历史原因——其多线程的设计主要是为了第一点：协调多种类型的作业。
>
> 它（CPython）确实有些适应不了多核的时代，想要去掉CLI也极其困难。

## 线程 vs 进程

进程的切换开销较大，所以在系统中不宜设置过多的进程，切换频率也不宜太高。

进程有如下两点属性：

* 进程是一个拥有资源的独立单元
* 进程是一个可以被处理器独立调度和分配的单元

为了使多个程序更好地并发执行，并尽量减少操作系统的开销，故考虑将进程的部分属性剥离出来（即**能被处理器独立调度和分配**，但**不拥有资源**），并称之为：**线程**。

线程本身不能单独运行，**只能包含在进程**中，是进程中相对独立的一个控制流序列。

> 一个进程的多个线程驻留在相同的地址空间中，共享数据和文件。
>
> 一个线程修改了一个数据项（或文件），其他线程可以了解和使用此结果数据（或文件）。[^1]

## 线程状态

新建状态、就绪状态、运行状态、阻塞状态及死亡状态。



## 线程的实现

### 内核级线程

依赖于内核，由操作系统内核完成创建和撤销工作的线程。

### 用户级线程

不依赖于操作系统核心，不需要操作系统内核了解用户级线程的存在。



### 多线程模型

一些系统同时支持用户级线程和内核级线程，因此可以根据两者的连接方式，分为三种多线程模型。

* 多对一
  * 优点：效率较高
  * 缺点：即使有多核处理器，同属一个内核线程的若干用户级线程只能并发而不能真正并行。
* 一对一
  * 优点：可以实现多线程并行
  * 缺点：耗费资源
* 多对多
  * 综合了前两种的优劣，折中的选择



[^1]:《天勤计算机考研高分笔记系列-操作系统》
