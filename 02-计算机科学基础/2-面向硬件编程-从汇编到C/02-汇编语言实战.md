照着《x86汇编语言：从实模式到保护模式》[^1]亦步亦趋。



# 第一份代码：主引导扇区

## 背景知识

众所周知，计算机通电启动时，若硬盘是首选的启动设备，那么ROM-BIOS将试图读取主引导扇区的内容到逻辑地址0x0000:0x7c00处。

若主引导扇区的内容有效，则通过转移指令`jmp 0x0000:0x7c00`跳转执行主引导扇区的内容。（一般来说主引导扇区的代码会检测并加载操作系统）

> 更多关于计算机启动这部分的详细内容，比如为什么是0x7c0000等，欢迎垂阅我在操作系统部分的笔记。

## 初始化段寄存器

```assembly
mov dx,0xb800
mov es,dx
```

Intel的处理器不允许将一个立即数传送到段寄存器，所以需要像上述代码一样通过通用寄存器中转一下。



## 显存访问和字符显示

屏幕上的每个字符对应现存中的两个连续字节，第一个字节表示具体的信息（ASCII等编码），第二字节表示显示属性，包括字符颜色和底色。

第二字节中低四位定义前景色，高四位定义背景色。

高四位四个比特分别代表KRGB，RGB很好理解，K表示闪烁，K=0时不闪烁，K=1时闪烁。低四位的四个比特分别代表IRGB，I代表亮度，为0正常亮度，为1高亮。

> 这种方法在Winodws的命令行中也有传承，通过`color xx`命令调整前景色和背景色，第一个x就是高四位背景色，第二个x就是低四位前景色，

> 当屏幕一片漆黑时，其实显示的全是黑底白字的空白字符，显存中的内容自然也是黑底白底的空白字符，空白字符ASCII码0x20。

至此，就可以开始用汇编手写屏幕输出的字符内容了。

> 在多数汇编器中允许直接用`'A'`、`'B'`这样的字符，不用手动查ASCII表。

## 标号和无限循环

下图为nasm汇编器生成的LST文件

![image-20210303125723324](C:\Users\Five\Desktop\note\img\image-20210303125723324.png)

lst文件中从左到右依次为行号、指令的汇编地址、指令编译后的机器码、源程序。

> 当编译好的程序加载到物理内存后，它在段内的偏移地址和它在编译阶段的汇编地址是相同的。

```assembly
infi: jmp near infi
```

![image-20210303132027585](C:\Users\Five\Desktop\note\img\image-20210303132027585.png)

如图所示的标号`infi`，当汇编器进行最后的汇编时，会把标号`infi`处理成汇编地址`0000012B`。

下面的写法效果一样，`infi`会标成`jmp`的汇编地址。

```assembly
infi: 
	jmp near infi
```

我们的代码只有极小一段，在处理器处理完（肉眼都无法察觉的速度）后，会继续处理后面的内容——但后面已经没有了。此时需要一个死循环，如上述代码所示，至少不让CPU处理后面的空白数据区域。

上述代码中`near`关键字表示目标位置依旧在当前代码段内。



## Hello World

### 一个有效的主引导扇区

`db`、`dw`、`dd`定义`Byte`、`word`、`double word`变量。

```assembly
times 361 db 0
dw 0xaa55
```





瞧这Hello World，长得多喜庆

![](C:\Users\Five\Desktop\note\img\1614751554(1).jpg)



## 再写主引导扇区

对应《x86汇编语言：从实模式到保护模式》第6章内容。

```assembly
jmp near start
         
mytext db 'H',0x07,'e',0x07,'l',0x07,'l',0x07,'o',0x07,' ',0x07, 'w',0x07,'o',0x07,\
            'r',0x07,'l',0x07,'d',0x07,'!',0x07
number db 0,0,0,0,0
  
start:
       mov ax,0x7c0                  ;设置数据段基地址 
       mov ds,ax
       
       mov ax,0xb800                 ;设置附加段基地址 
       mov es,ax
         
       cld
       mov si,mytext                 
       mov di,0
       mov cx,(number-mytext)/2      ;实际上等于 13
       rep movsw

```

一般来说在顺序执行的指令之间不应该夹杂普通数据，除非像上述代码一样，通过`jmp`指令跳过普通数据段。



## 标号和段地址初始化

```assembly
label_a:
	mov ax,bx
```

标号到底标的是个什么？

上述代码中的标号`label_a`在经过编译器编译后，计算的汇编地址位0x05，程序被加载后，其在段内的偏移地址仍然是0x05。



> 编译器编译时会作如下假设：
>
> 编译后的代码从某个内存段、偏移地址为0的地方开始加载。



# 第一个计算任务：累加

一如既往定义数据，并用`jmp`指令跳过数据区到真正的起始地址。

```assembly
	jmp near start
message db '1+2+3+...+100='
start:
	mov ax,0x7c0
```

直接贴代码吧，代码是独立写的，几次小小的“技术调整”之后就能run了，我已经飘起来了。

```assembly
jmp near main

info db 'The result of 1+2+...+99+100 is '

main:
    mov ax,0x7c0
    mov ds,ax

; move prompt string
    mov cx,main-info
    mov si,info

    mov ax,0xb800
    mov es,ax
    mov di,0
    
mov_str:
    mov al,[si]
    mov [es:di],al
    inc si
    inc di
    mov byte [es:di],0x0f
    inc di
    loop mov_str

; calculate
    mov cx,100
    xor ax,ax
sum:
    add ax,cx
    loop sum

; convert binary to decimal and push
    xor cx,cx
    mov ss,cx
    mov sp,cx

    mov bx,10
    xor cx,cx
dec2bin:
    inc cx
    xor dx,dx
    div bx
    or dl,0x30
    push dx
    cmp ax,0
    jne dec2bin

; pop and show
get_dec:
    pop dx
    mov [es:di],dl
    inc di
    mov byte [es:di],0x07
    inc di
    loop get_dec

    jmp near $
       

times 510-($-$$) db 0
                 db 0x55,0xaa
```



# 模拟程序加载

* 操作系统是如何被加载的
* 操作系统是如何加载其他程序的

当然可以完全不关心以上两个问题，也不影响驾驭计算机这个工具。

但俺的好奇心不允许。

## 访问硬盘

### 访问设置

```assembly
mov dx,0x1f2
mov al,0x01
out dx,al
```

`0x1f2`端口设置要读取的扇区数量，若该值为0，则表示要读取256个扇区。

```assembly
mov dx,0x1f3
mov al,0x02
out dx,al ;LBA地址7~0

inc dx
mov al,0x00
out dx,al ;LBA地址15~8

inc dx
mout dx,al ;LBA地址23~16

inc dx
mov al,0xe0 ;LBA模式，主硬盘，以及LBA地址27~24
out dx,al
```

如上述代码所示，在0x1f3~0x1f6四个端口中设置28位的扇区号，其中0x1f6比较特殊，还剩下高位4个bit。

* 高3位`111`表示LBA模式
  * `101`表示CHS模式
* 第4位用于指示硬盘号，0表示主盘，1表示从盘



### 0x1f7

0x1f7既是命令端口，又是状态端口，其中

* 第0位为错误位，若前一个命令执行错误，则置为1
  * 更具体的错误信息在0x1f1端口，其包含硬盘驱动器最后一次执行命令后的状态
* 第3位DRQ为1表示硬盘已经准备好和主机交换数据
* 第7位BSY为1表示硬盘正忙。

```assembly
mov dx,0x1f7
mov al,0x20 ;读命令
out dx,al
```

硬盘将0x1f7端口的第7位置为1并开始工作，准备就绪后再将此位清零。

```assembly
	mov dx,0x1f7
.waits:
	in al,dx
	and al,0x88
	cmp al,0x08
	jnz .waits
```

上述代码用于判断是否准备完成，即判断0x1f7端口的第7位是否为0，第3位是否为1.



### 读取数据到内存

`0x1f0`是硬盘接口的数据端口，是一个16位端口

一旦硬盘控制器空闲且准备就绪，即可从该端口读入/写入数据。

```assembly
	mov cx,256
	mov dx,0x1f0
.readw:
	in ax,dx
	mov [bx],ax
	add bx,2
	loop .readw
```



## 分段和重定位

### 段及其属性

NASM使用汇编指令`SECTION`或者`SEGMENT`来定义段。

```assembly
SECTION 段名 [align=16] [vstart=0x7c00]
SEGMENT 段名 [align=16] [vstart=0x7c00]
```

NASM不在乎段的用途、类型，只是用段来分隔程序中的不同内容。

> 若程序不以段定义语句开始，则这些内容默认自成一个短。
>
> 就像之前的代码，整个程序中都没有段定义语句，则整个程序自成一个段。

> 因为段机制的存在，物理地址 = 段寄存器 << 4 + 偏移地址，所以很自然地，Intel处理器要求段在内存中的起始物理地址起码是16字节对其的（低四位为0）。
>
> 在汇编程序中，可以通过`align=16`这种语句指定SECTION的地址对齐方式。

> 可以用类似`vstart=0x7c00`子句来指定当前段的基础偏移量，后续的所有标号在计算地址时根据当前段的偏移量再加上相对值来进行偏移计算。
>
> 如`SECTION　mbr vstart=0x7c00`，则段mbr内所有的标号其汇编地址是在`0x7c00`这个偏移量的基础上计算得到的。



### 程序头部信息

就像硬件生厂商和程序员想要实现无缝衔接，就需要约定一个起始地址`0x7c00`一样，加载程序（loader，特殊的program）和被加载程序（一般的program）之间也需要有一些规范和约定，从而loader可以有一个通用的方法加载其他program。

> 比如在Linux下的ELF（Executable and Linkable Format）格式和Windows下的PE（Portable Executable）格式

在此处模拟实例中，因为加载程序和被加载程序都是同一个人（自己）写的，所以甚至可以不需要指定啥具体的规范——反正要被加载程序也是我们自己写的，自然应该知道怎么正确加载它。

不过规范还是得有的。

* 被加载程序的尺寸
  * loader需要根据该信息决定读取多少个逻辑扇区
* 应用程序的入口点
  * 就像`0x7c00`是主引导记录的入口点
* 段重定位表



### 为什么要重定位



# 走近中断





# 保护模式

> 为了避免无意中用全0的索引来选择描述符，处理器要求GDT中第一个描述符定义成空描述符。

## 关于切换一刹那

* 疑惑1：CS寄存器的访问内存的方式什么时候改变的？或者说设置CR0开启保护模式（`mov cr0,eax`）后，下一条指令去哪取指？

还是像实模式一样用CS<<4 + IP吗？可是这会儿不应该已经进入保护模式了吗？

去段描述符表中取指令吗？可是这时候的CS寄存器还是物理地址，而不是段选择子呀。

当然，现代处理器都是流水线嘛，在执行`mov cr0,eax`的时候，下一条指令已经取好了。可是——开个保护模式难道还要依赖底层实现上的流水线技术嘛？



* 疑惑2：书[^1]上说，即使是在实模式下，段寄存器的描述符高速缓存器也被用于访问内存，只不过此时仅低20位有效，高12位是全零。

这又不太理解了，实模式下段寄存器的内容不就是物理地址吗？也没有GDT这种东西啊，你高速缓存缓存了个寂寞啊？

难道说在cache里放0x007c到0x007c这样一个映射？y=x的映射？这尼玛不是逗我呢吗？



所幸书本[^1]后面也给出了解释：

实模式下，CS在高速缓存器中对应的描述符的值为0x00009300 0x0000ffff：

![image-20210416164759371](C:\Users\Five\Desktop\note\img\image-20210416164759371.png)

对，是有内容的，**描述符高速缓存器中的这些内容是加电之后预置的**，不是来自于描述符表。

将实模式下的CS描述符值0x00009300 0000ffff对照下表

![](C:/Users/Five/Desktop/note/img/4b909029486695c4aefe6dce20504555c9b08e81.jpg)

其基地址为0x0000 0000 0000 0000——所以表现就和实模式一模一样。

当然还可以看到更多属性，如Type为0x00009300中那个3，即0011，9（1001）对应P、DPL、S三个属性。

> 所以当真正进入保护模式后，自然也要刷新段描述符表高速缓存器。



### 一举多得的jmp指令



进入保护模式后，回过头来看原来在高速缓存器中的内容其实不再有效了。

**对描述符有效与否的检查，通常只在加载段寄存器（并刷新描述符高速缓存器）的时候进行**

```assembly
jmp 0x0008:0x0002
mov ds,ax
```

执行这类指令的时候，会先找到描述符，如果描述符有效，就将选择子加载到段寄存器，并把描述符加载到高速缓存器。

一般来说，一个不合格的、无效的描述符不可能被加载到段寄存器的描述符高速缓存器。

## 



[^1]:《x86汇编语言：从实模式到保护模式》李忠 王晓波 余洁 著