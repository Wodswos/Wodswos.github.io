# 内存管理

## 回顾汇编的内存

C毕竟是编译为汇编、再进一步汇编为机器码的，所以C的内存管理显然也是以汇编的内存管理为基础的。

在汇编中就有关于栈的操作指令`push`和`pop`。

在经典的8086寄存器模型中有4个段寄存器，分别是CS、DS、ES、SS（Stack Segment），除AX、BX、CX、DX外的四个通用寄存器SP（Stack Pointer）、BP、SI、DI。

汇编中的栈指的是栈段，和代码段、数据段、附加段一样，是一片真实的内存空间，由SS寄存器指向栈底，SP寄存器指向栈顶偏移。

> 栈底在高地址，向低地址增长扩展。

此时若使用类似`push ax`的指令，会使得SP寄存器减去操作数据的长度（单位为字节），并将数据压入`SS << 4 + SP`的位置。

同理，若使用类似`pop ax`的指令，则会将地址为`SS << 4 + SP`的内容取出到寄存器，并给SP寄存器加上操作数据的长度。

> 一般初始化时直接将SP设为0，这样一来`push`第一个数据时，SP自减数据长度会从0变成0xFFFE或者0xFFFF（取决于数据长度），是当前（64KB的）栈段的最高地址，也能自然而然地将第一个数据存入最高地址。
>
> 判断栈是否为空也只需要将SP和0进行比较即可。

### 为什么要有栈？

因为结构化语言里函数（子程序）调用最方便的实现方式就是用栈，以至于现在绝大部分芯片都对栈提供芯片级的硬件支持，一条指令即可搞定栈的pop操作。

Intel于1978年发布16位微处理器“8086”，此时C语言已经走向成熟和推广，甚至C++也开始孕育。



## 内存布局和分配

在C++中，内存分成5个区：堆、栈、自由存储区、全局/静态存储区和常量存储区。



```c++
void f() { 
    int* p=new int[5]; 
}
```

上述代码表示在内存的栈部分中存放一个指针p，该指针p指向一块动态申请的堆内存。

其（机器码和）汇编代码为：

```lst
00401028 push 14h

0040102A call operator new (00401060)

0040102F add esp,4

00401032 mov dword ptr [ebp-8],eax

00401035 mov eax,dword ptr [ebp-8]

00401038 mov dword ptr [ebp-4],eax
```



例子取自《CS: APP》课程视频

```c
typdef struct{
    int a[2];
    double d;
}struct_t;

double fun(int i){
    volatile struct_t s;
    s.d = 3.14;
    s.a[i]=1073741824;
    return s.d;
}
```



最后执行`fun()`函数可以得到如下一系列结果

```
fun(0) --> 3.14
fun(1) --> 3.14
fun(2) --> 3.13999998664856
fun(3) --> 2.00000061035156
fun(4) --> 3.14
fun(6) --> Segmentation fault
```

![image-20210514170752629](C:\Users\Five\Desktop\note\img\image-20210514170752629.png)

> 关于“堆栈”一词
>
> 从初进大学开始就不停地听到堆栈堆栈，耳朵都起茧子了。但说来惭愧，我好像也从没有弄清过堆栈到底是什么意思。
>
> “堆”、“栈”以及“堆栈”，都是被经常提起的名词，在不同语境下又好像有不同的意义，很容易让人迷惑。
>
> 
>
> 总的来说，造成混乱有两个主要原因：
>
> * 堆栈既可以是一个并列短语，也可以是一个偏正短语，
>   * 作为并列短语时“堆栈”一词指堆和栈（heap and stack）
>   * 作为偏正短语时“堆栈”一词作为栈的别名（即“栈”=“堆栈”，英文都是stack）
>     * 所以为了减少混淆是不是应该避免这种用法，还能省个字。
> * 堆和栈本身也都是多义词，不同语境（内存管理、数据结构等）下意义不同
>   * 堆≠数据结构的堆，内存分配的栈≈数据结构的栈
>   * 内存分配中所说的堆与数据结构中的堆就完全是两个东西了，只是恰好都叫“堆”罢了
>     * 在数据结构中，堆是一种特殊的树
>     * 而在内存分配中，堆单纯就是指动态分配的内存区域
>     * 以汇编为例，其栈段由栈段寄存器`SS: Stack Segment`指定，而堆段对应的是数据寄存器`DS: Data Segment`
>       * 所以是不是可以尽量避免内存分配中“堆”这种叫法，直接叫“动态内存区”。
>



### Stack Overflow

`Stack Overflow`，一个经典得不能再经典的错误。



C的栈在x86-64上是直接绑定到CPU指令的，实现上极其精简，因此它与堆不同，没有动态增长、动态缩小的功能，一旦分配出来就会永远占用相应的空间。

每个线程都会占用独立的栈空间，这样对于线程数很多的进程来说，如果栈空间分配得过多，就会很浪费内存空间。相反，堆空间可以一开始分配得很小，然后不停向上增长，释放相应的空间之后还可以归还给操作系统，因此适合处理比较大的空间。

对于一定要占用比较大的栈空间的情况，可以指定栈空间大小。[^3]

其他语言的栈并不一定是这样的，比如Python的栈就是假的，用堆空间模拟的，只有递归深度限制，而没有容量限制。[^3]



### 你听过Heap Overflow吗

堆和栈不同，堆是向高地址扩展的数据结构，是不连续的内存区域。

系统一般用链表来存储的空闲内存地址的，堆的大小受限于计算机系统中有效的虚拟内存，一般自然不会溢出。



### 内存回收

栈的内存分配和回收由编译器管理，通常包括局部变量、函数参数等。

堆的内存分配和释放由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。



## malloc 和 free





## 内核空间和用户空间[^2]

尽管现在的内存空间都号称是平坦的，但实际上内存仍然在不同的地址区间有着不同的地位，例如，大多数操作系统都会将 4GB 的内存空间（32位机子）一部分挪给内核使用，应用程序无法直接访问这一段内存，这一部分内存地址被称为 内核空间。

> Windows 在默认的情况下会将高地址的 2GB 空间分配给内核（也可以配置 1GB）。
>
> Linux 默认情况下将高地址的 1GB 空间分配给内核。

![](C:/Users/Five/Desktop/note/img/v2-18fabec59a3f38e36a371caa5d1093a9_1440w.jpg)









[^1]: https://www.cnblogs.com/hanyonglu/archive/2011/04/12/2014212.html
[^2]: 浅谈程序的内存布局 - herongwei的文章 - 知乎 https://zhuanlan.zhihu.com/p/77122692
[^3]: 为什么栈相对于堆很小？ - 灵剑的回答 - 知乎 https://www.zhihu.com/question/59238963/answer/163678156