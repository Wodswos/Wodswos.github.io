

Linking is the process of collecting and combining various pieces of code and data into a single file that can be loaded into memory and executed.[^1]

* Linking can be performed at compile time, when the source code is translated into machine codes. 
  * 即静态链接。
* Linking can be performed at load time, when the program is loaded into memory and executed by the loader.
* Linking can even be performed at run time, by application programs.



在蛮荒时代，链接是手动的，现在一般有链接器自动完成。

Linkers enable separate compilation. 链接才是计算机界模块化的鼻祖。



* Understanding linkers will help you build large programs.
* Understanding linkers will help you avoid dangerous programming errors.
* Understanding linking will help you understand how language scoping rules are implemented.
* Understanding linking will help you understand other important systems concepts.
* Understanding linking will enable you to exploit shared libraries.

# 目标文件和可执行文件

下图为代码编译过程[^1]：

![image-20201206144004646](C:\Users\Five\Desktop\note\img\image-20201206144004646.png)

从汇编到Relocatable Object Programs，再从Relocatable Object Programs到Executable object program。

## Linux和ELF

Unix/Linux平台下三种主要的可执行文件格式：a.out（Assembler and link editor output）、COFF（Common Object File Format）、ELF（Executable and Linking Format）。

> In 1999, it was chosen as the standard binary file format for Unix and [Unix-like](https://en.wikipedia.org/wiki/Unix-like) systems on [x86](https://en.wikipedia.org/wiki/X86) processors by the [86open](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format#86open) project.
>
> 86open** was a project to form consensus on a common [binary file](https://en.wikipedia.org/wiki/Binary_file) format for [Unix](https://en.wikipedia.org/wiki/Unix) and [Unix-like](https://en.wikipedia.org/wiki/Unix-like) [operating systems](https://en.wikipedia.org/wiki/Operating_system) on the common [PC compatible](https://en.wikipedia.org/wiki/PC_compatible) [x86](https://en.wikipedia.org/wiki/X86) architecture, to encourage software developers to port to the architecture.[^5]

Executable and Linking Format，名字已经说明了该类型的两种用途，也说明了看待ELF的两种视角：链接和执行。

从链接的角度来看，ELF文件是按Section的形式存储的，从执行的角度看，ELF文件又可以按Segment来划分。

![](C:/Users/Five/Desktop/note/img/800px-Elf-layout--en.svg.png)

> ELF可以描述Linux下可执行文件、可重定位目标文件、共享目标文件、核心转储文件的存储格式——而不仅仅是其中的某一种。

### 文件头

ELF文件中最开始的52个字节记录了ELF文件头部的信息。通过它可以确定ELF文件内程序头表的段表的位置及大小。

从文件头可以找到程序头表、段表，从段表可以找到其他所有段。

通过`readelf`命令可查看ELF文件内容。如`readelf -e /bin/ls`其头文件内容如下

![image-20210318192150202](C:\Users\Five\Desktop\note\img\image-20210318192150202.png)

## 链接视角：可重定位目标文件

Object files come in three forms:[^1]

* Relocatable Object File：在编译阶段，和其他文Relocatable Object File黏合成可执行文件。
* Executable Object File：可以直接被加载执行
* Shared Object File：一种特殊的重定位目标文件，可以在加载或运行时动态链接

Typical ELF relocatable object file[^1]:

![image-20210319102836636](C:\Users\Five\Desktop\note\img\image-20210319102836636.png)

The ELF header begins with a 16-byte sequence that describes the word size and byte ordering of the system that generated the file.

前三个段/区（Section）比较好理解，

* `.text`存放代码
* `.rodata`存放只读数据
* `.data`存放初始化的全局变量和静态变量

BSS，Block Started by Symbol，通常用来存放程序中未初始化的全局变量和静态变量的一块内存区域，在程序执行之前BSS段会自动清0。

bss段只是为未初始化的全局变量和静态变量预留位置，并没有实际的内容。

但是程序运行时，bss段是要占内存空间的，因此可执行文件必须要记录所有未初始化的全局变量和静态变量的大小的总和，作为bss段的大小。

程序运行结束后自动释放。

> The use of the term .bss to denote uninitialized data is universal. It was originally an acronym for the “block started by symbol” directive from the IBM 704 assembly language (circa 1957) and the acronym has stuck.
>
> A simple way to remember the difference between the .data and .bss sections is to think of “bss” as an abbreviation for “Better Save Space!”[^1]

`.symtab`，符号区

`.rel.text`

`.rel.data`

`.debug`：It is only present if the compiler driver is invoked with the -g option.

`.line`：It is only present if the compiler driver is invoked with the -g option.

`.strtab`: String Table



### Symbol和Symbol Table

共三种符号

* 当前模块定义并可由其他模块Reference的Global Symbol
* 其他模块定义并由当前模块Reference的Global Symbol
* Local Symbol



#### Static和Local

全局变量一般都是Global Symbol，而一般变量（带有作用域的局部变量）不归Symbol Table和链接器Linker管，而是在运行时由栈来管理。

当变量标记有static关键字时，编译器会在`.data`或者`.bss`区给其分配空间，并且在符号表创建一个本地链接符号。

static的变量/函数对应的符号就是Local Symbol。

```c
int f() {
	static int x=0; 
    return x;
}
int g() {
	static int x=1; 
    return x;
}
```

编译器会赋予上述代码中的两个`static int x`不同的名字，然后传递给汇编器。如下图所示的`x.1832`和`x.1835`

![image-20210319163603947](C:\Users\Five\Desktop\note\img\image-20210319163603947.png)

#### Entry和Symbol

汇编器创建符号表，并放置在`.symtab`区，符号表由entries组成.

Entry的格式如下所示：

![image-20210319131155004](C:\Users\Five\Desktop\note\img\image-20210319131155004.png)

* `int name`
  * 表示在`.strtab`（字符串表）中的字节偏移量。
  * 指向一个以NULL结尾的字符串（符号的名称，如函数名或全局变量名）
  * 众所周知，`int`32位（不考虑8086等过时机器上的过时编译器），又众所周知，以字节为单位的话意味着32bit可以有4GB寻址空间，所以用一个`int`标记字符串表中的偏移量一般情况下绰绰有余。
* `char type:4,binding:4`
  * The type is usually either data or function.
  * The binding field indicates whether the symbol is local or global.
* `short section`
  * 如1表示`.text`，2表示`.rodata`，3表示`.data`
  * 三种特殊的pseudo-section在Section Header Table中没有对应
    * ABS is for symbols that should not be relocated
    * UNDEF  is for undefined symbols
      * 在当前模块中引用，但在其他模块中定义
    * COMMON ：未初始化的全局变量
      * 和`.bss`有点py交易
      * 涉及到强弱Symbol的选择
  * 伪section只在重定位目标文件中，不能出现在执行文件中
* `long value`
  * 对于可重定位文件，`value`是相对于section的一个偏移地址
  * 对于可执行文件，`value`就是运行时的逻辑地址(an absolute run-time address)。



```c
int sum(int *a, int n); 
int array[2] = {1, 2};
int main() {
	int val = sum(array, 2);
    return val;
}
```

上述代码经过`gcc -c main.c`编译后可得到重定位目标文件`main.o`，再用`readelf -a main.o`可查看其Symbol Table

![image-20210319155331762](C:\Users\Five\Desktop\note\img\image-20210319155331762.png)

由于`sum`函数并未在当前c文件定义，故其Section为UNDEF。



### Relocation Entries

Relocation entries for code are placed in `.rel.text`. Relocation entries for data are placed in `.rel.data`.

![image-20210320151607166](C:\Users\Five\Desktop\note\img\image-20210320151607166.png)

* `long offset`
* `long type:32, symbol:32`
  * Linux定义了32种Relocation类型
  * `R_X86_64_PC32`使用相对当前32位PC寄存器地址重定位。
  * `R_X86_64_32`
* `long addend` ​​



### Section Header Table

| Type | Address | Offset | Name | Size | EntSize | Flags | Link | Info | Align |
| ---- | ------- | ------ | ---- | ---- | ------- | ----- | ---- | ---- | ----- |
|      |         |        |      |      |         |       |      |      |       |



为什么要将程序的指令和数据进行分段呢

* 局部性，只有这个函数用这个参数，故没必要放在数据段
* 当程序被装载后，数据和指令被映射到两个不同的虚存区域。数据区域对进程是可写可读的，而指令区只是可读的，这样就避免了进程修改指令带来的问题。
* 当系统中运行着多个该程序的副本时，它们的指令是相同的，数据可能不同。因此在内存中只需保存一份该程序的指令，这样就节省了大量的存储空间。



![image-20210318192233798](C:\Users\Five\Desktop\note\img\image-20210318192233798.png)

## 运行视角：可执行文件

可以说，夹在可重定位目标文件和可执行文件之间的坎就是链接。



Program Headers包含Type、Offset、VirtAddr、PhysAddr、FileSiz、MemSiz、Flg、Align等信息。

![image-20210318202805336](C:\Users\Five\Desktop\note\img\image-20210318202805336.png)



## 其他文件格式

不同平台的目标文件：

* The first Unix system in Bell Labs used the `a.out` format.
* Windows uses the Portable Executable (PE) format
* Mac OS-X uses the Mach-O format
* Modern x86-64 Linux and Unix systems use Executable and Linkable Format (ELF).



nasm支持如下格式的编译。

```
   bin                  Flat raw binary (MS-DOS, embedded, ...) [default]
   ith                  Intel Hex encoded flat binary
   srec                 Motorola S-records encoded flat binary
   aout                 Linux a.out
   aoutb                NetBSD/FreeBSD a.out
   coff                 COFF (i386) (DJGPP, some Unix variants)
   elf32                ELF32 (i386) (Linux, most Unix variants)
   elf64                ELF64 (x86-64) (Linux, most Unix variants)
   elfx32               ELFx32 (ELF32 for x86-64) (Linux)
   as86                 as86 (bin86/dev86 toolchain)
   obj                  Intel/Microsoft OMF (MS-DOS, OS/2, Win16)
   win32                Microsoft extended COFF for Win32 (i386)
   win64                Microsoft extended COFF for Win64 (x86-64)
   ieee                 IEEE-695 (LADsoft variant) object file format
   macho32              Mach-O i386 (Mach, including MacOS X and variants)
   macho64              Mach-O x86-64 (Mach, including MacOS X and variants)
   dbg                  Trace of all info passed to output stage
   elf                  Legacy alias for "elf32"
   macho                Legacy alias for "macho32"
   win                  Legacy alias for "win32"
```

### Windows

Portable Executable，可移植的执行文件。虽然名字这么叫，但其实仅限于DOS/Win系统下

PE文件又可以分为exe文件和dll文件。

PE文件结构如下[^3]

![](C:/Users/Five/Desktop/note/img/20190306224929442.png)

![](C:/Users/Five/Desktop/note/img/20190306225025670.jpg)



* Windows的obj文件，相当于Unix-Like的o文件
* Windows的dll文件，相当于Unix-like的so文件
* Windows的lib文件，相当于Unix-Like的a文件
* Windows的PE文件，基本相当于Unix-Like的elf文件

### bin

不知道有没有这样一个疑问：不是说好的汇编和机器码一一对应了吗？怎么莫名其妙中间又隔了一层劳什子目标文件？

以下是个人想法：

目标文件对应的编译链的链接这一环，不是一开始就有的。

最原始的时候应该是没有也不需要链接的——最简单的汇编的确不需要链接——比如写个主引导记录，你能链接啥？有啥可给你链接的？

随着标准库的发展、模块化的发展、乃至操作系统的发展，链接能帮助程序员减少很多重复劳动，屏蔽很多繁琐的细节，建立抽象化概念，链接也因此成为了高级语言编译的重要一环。

有没有没有目标文件的？当然有，bin就不需要生成目标文件。

> The `bin` format does not produce object files: it generates nothing in the output file except the code you wrote. Such `pure binary` files are used by MS-DOS: `.COM` executables and `.SYS` device drivers are pure binary files. Pure binary output is also **useful for operating system and boot loader development**.

`bin`一般汇编为16位（老古董了），如果需要32位或者64位，需要手动指定。



* COM

在迪吉多公司于20世纪70年代推出的操作系统中，.COM被用做包含操作系统支持命令的文本文件的拓展名（类似于Windows系统的.cmd文件）。随着引进CP/M的引进（微型计算机的操作系统），COM扩展相的文件改变为的可执行文件。

该格式后来被结转到MS-DOS。虽然MS-DOS中已有更常见的.exe文件格式的，紧凑的COM文件仍然保持活力，并在MS-DOS频繁使用。

COM文件中没有附带任何支持性数据，仅包含可执行代码。文件头即为第一句执行指令。没有重定位的信息，这样代码中不能有跨内存段(segment)操作数据的指令，因此代码与数据只能限制在同一个64KB的内存段中。



# 静态链接

静态链接是在编译链接时直接将需要执行的代码拷贝到调用处。

在实际开发中，不可能将所有代码放在一个源文件中，所以会出现多个源文件，源文件之间存在多种依赖关系。

但每个源文件都是独立编译的，即每个`.c`文件会生成一个`.o`文件。

为了满足前面的依赖关系，需要将这些源文件产生的目标文件进行链接。

## 举个栗子

对于如下两个C文件。[^1]

```c
int sum(int *a, int n); 
int array[2] = {1, 2};
int main() {
	int val = sum(array, 2);
    return val;
}
```

```c
int sum(int *a, int n) {
	int i,s=0;
	for(i=0;i<n; i++) { 
        s += a[i];
    }
    return s;
}
```

用GCC进行编译

```bash
gcc -Og -o prog main.c sum.c
```

上述命令的背后其实GCC Drvier一共调用了如下操作

```bash
cpp [other arguments] main.c /tmp/main.i
cc1 /tmp/main.i -Og [other arguments] -o /tmp/main.s
as [other arguments] -o /tmp/main.s /tmp/main.o
# 对sum.c重复上述步骤
ld -o prog [system object files and args] /tmp/main.o /tmp/sum.0
```

Linker主要完成两个任务：

* Symbol resolution
* Relocation

## Symbol Resolution

### 给谁Resolution

当然是给每一个Symbol啦。

### 如何Resolution

传给Linker的是一个重定位目标文件的集合，每个目标重定位目标文件都可能定义了一堆Symbol，有Local的也有Global的。





* 在当前模块没有找到对应的Symbol时，会去其他模块中找
* 所有模块中都找不到该Symbol对应的define，就报错



#### 不同模块间的重名

单模块中重名会直接在编译阶段报错。

到了链接阶段，不同模块之间还是可能会面临重名，编译已经撒手了，此时链接器该如何抉择？

Here is the approach that Linux compilation systems use.[^1]

当编译器把Global Symbol传给汇编器时，还会带上该Symbol `strong`或者`weak`的标签。函数和有初始化的全局变量`strong`，没有定义初始化的全局变量`weak`。

然后遵循以下三条原则进行链接：

* 两个`strong` Symbol直接报错
* 一强一弱选强
  * 这种选择可能——非常有可能在运行时造成一系列错误
  * 比如两个同名全局变量，归两个函数管，一个没初始化，结果都链接到哪个强Symbol上了，管弱Symbol的那些函数就直接操作那个强Symbol，这能不乱套嘛。
  * 再比如一个弱的double被强的int覆盖了，那操作这个int的时候还可能会越界，直接影响到其他数据——Double比Int长
* 两个/多个弱的就幸运抽奖，随便链一个
  * 跟第二条一样可能造成错误

> 悬崖边竖着Waning的牌子，路过的人都没出事，只有程序员跳下去了。

玩笑这么开，但Warning还是得重视——尤其是当你不确定自己能不能hold住这个Warning可能带来的后果的时候。

`-Werrror`选项可以使得GCC将所有Warning视为Error，高标准要求代码。



#### C++和Java

C++、Java这些更modern的语言，都支持函数重载，其核心就是`mangling`（函数签名？），反向过程成为`demangling`

如`Foo::bar(int, long) `is encoded as `bar__3Fooil`







### 回顾C语言

当明白了编译的来龙去脉，也可以更好地回顾C语言的种种特性。



* 函数声明
  * “函数声明”的作用则是把函数的名字、函数类型以及形参类型、个数和顺序通知编译系统，以便在调用该函数时系统按此进行对照检查
    * 没有函数声明会报`warning: implicit declaration of function`
    * 不过，只是warning，而不是error。正经程序员谁在乎warning啊，你在乎吗？我不在乎。
      * 悬崖边的Warning？跳就完事了，只是Warning而已。
    * 毕竟关键是define，而不是declaration。只要链接的时候还是能给出Symbol对应的define就还是你好我好大家好。
  * 在主文件的编写中，好像都喜欢把定义的函数放后面，`main()`方法放前面，在`main()`之前再添加个函数声明。
    * 至今不知道这样的写法和直接把函数放前面的写法编译结果是否有不同，应该是为了文件/代码结构清晰一些吧？
* 链接的文件中有重名的函数和全局变量会报错：`multiple definition of `函数名/全局变量名
  * C++函数签名包括函数名、参数个数、参数类型，所以可以重载
  * C语言函数签名只包含函数名，函数名重了就暴毙，去你丫的重载
* 函数名和全局变量（反正就是Symbol）重名了也会报错：`redeclared as different kind of symbol`
  * 静态变量应该也不能重名，毕竟都是Symbol，不过懒得动手测试验证了





## 静态链接库

ISO C99 defines an extensive collection of standard I/O, string manipulation, and integer math functions such as `atoi`, `printf`, `scanf`, `strcpy`, and `rand`. They are available to every C program in the `libc.a` library. 

ISO C99 also defines an extensive collection offloating-pointmath functions such as `sin`, `cos`, and `sqrt` in the `libm.a` library.

标准库对程序员而言是一种极大的便利，但C的标准库很大，该如何实现呢？

### object file和Archive

```
linux> gcc main.c /usr/lib/libc.o
```

如上所示，直接将所有的标准库放到一个Object File中，确实很方便，但Object File很大，编译出的程序也将包含整个Object File，变得很臃肿。

```
linux> gcc main.c /usr/lib/printf.o /usr/lib/scanf.o ...
```

如上所示，如果将Object File拆分得很细，又会使得编译命令很繁琐也很容易出错。

于是library的概念应运而生——扬两种方法之长，将Object File拆分得很细，然后将他们打包成一个library，当需要用到某个Object File时，无需指出具体的文件位置，只需声明其所在的library即可。

```
linux> gcc main.c /usr/lib/libm.a /usr/lib/libc.a
```

在Linux种，库的文件格式为`Archive`，后缀名（虽然Linux也不在乎后缀名）`.a`。

![image-20210320132629001](C:\Users\Five\Desktop\note\img\image-20210320132629001.png)

To create a static library of some functions, we would use the `ar` tool as follows[^1]:

```
linux> gcc -c addvec.c multvec.c 
linux> ar rcs libvector.a addvec.o multvec.o
```





### How Linker Use Static Libraries

Linker按照命令行从左到右的顺序扫描目标文件，链接过程中Linker会维护（maintain）三个集合：

* E: relocatable object files that will be merged to form the executable
* U: unresolved symbols
* D: symbols that have been defined in previous input files

例如：

```bash
gcc -static -o output main.c obj_file1.o c_file1.c obj_file2.o static_library.a
```

* 遇到`.o`文件则添加到集合E中，遇到`main.c`、`c_file1.c`等C文件GCC会自动将其编译成目标文件，添加到集合E中	
  * 并根据文件中的内容（Symbol和Definition）更新集合U和D。
* 遇到`.a`文件，则搜索该Archive中的目标文件中是否有U中的Symbol的定义（Definition），如有，则将该目标文件加入E，并将该目标文件的其他Symbol也一并加入D。
  * 如果有更新，这个过程会重复进行（毕竟引入了新的目标文件），直到E、U、D不再有新的更新
  * 至此Archive中没有被添加到E中的目标文件就被舍弃了
* 继续处理下一个输入文件
* 若最终U不为空，则报错`undefined reference`。



从上述内容中可以意识到，文件的输入顺序是会直接影响编译过程和结果的！

1. 比如目标文件`a.o`中的Symbol在某个Archive/Library中的某个目标文件`b.o`中定义
2. 但目标文件`a.o`在Archive后面输入，在Linker之前扫描Archive/Library的时候，已经把`b.o`舍弃了，其内的定义的Symbol自然也没放入D中
3. 此时Linker是不会回过头去再扫描一次该Archive的，于是这个Symbol定义就找不到了，就会报错`undefined reference`



这个例子说明，作为一种习惯，应该把库文件放在目标文件之后，至少能极大地避免这种错误。

如果库之间还有依赖，越底层地就越往后捎。

如果库之间互相都有调用，还能把一个重复库重复作为输入，如`foo.c`中有引用`libx.a`中的某个`obj_a.o`，而`obj_a.o`又需要引用`liby.a`中的某个`obj_b.o`，而`obj_b.o`又需要引用`libx.a`中的`obj_c.o`，则可以像下面这样写。

当然……更好的做法是合并两个lib，编译器会自己重复搜索。

```bash
gcc foo.c libx.a liby.a libx.a
```





#### main

CS/SE专业的第一节C语言课大概就会讲`main`函数是C程序的入口。

在最终生成可执行文件时，若在所有链接的目标文件中都找不到`main`函数，会报错`undefined reference to 'main'`。







## Relocation-重定位

符号和定义是一一对应起来了，但还需要重定位：合并所有的module，并分配run-time地址。

* Relocating  sections and symbol definitions.
* Relocating symbol references within sections.



# 动态链接

动态链接是在编译的时候不直接拷贝可执行代码，而是通过记录一系列符号和参数，在程序加载或运行时将这些信息传递给操作系统，由系统负责将所需的动态库加载到内存。

当程序运行到指定的代码时，去共享执行内存中已经加载的动态库可执行代码，最终达到运行时链接的目的。





# 重定位和地址的生成

 汇编程序在编写的时候是分段的，所以加载器需要计算和确定每个段的段地址。











[^1]:《Computer System: A Programmers Perspective》Randal E. Bryant
[^2]: https://blog.csdn.net/abc_12366/article/details/88205670
[^3]: https://en.wikipedia.org/wiki/Comparison_of_executable_file_formats
[^4]: https://bbs.pediy.com/thread-255670.htm
[^5]: https://en.wikipedia.org/wiki/Executable_and_Linkable_Format
[^6]:《x86汇编语言：从实模式到保护模式》