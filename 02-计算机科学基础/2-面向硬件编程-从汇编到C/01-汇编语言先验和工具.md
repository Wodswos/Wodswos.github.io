> 汇编语言阶段，我们依旧直接和硬件打交道——硬件的每一步都是我们说了算。
>
> 轮不到操作系统接管硬件，还抽象出什么进程、虚拟内存、文件的概念来对编程“指手画脚”。

```text
0100 0001
0001 0100
0010 0000
0001 0011
```

上述代码——这谁看得懂是什么意思？所以需要助记符

```text
MOV   1 ；寄存器存入1
ADD   4 ；寄存器的数字加4
SHL   0 ；乘2（介于我们设计的乘法器暂时只能乘2，这个0是占位的）
ADD   3 ；再加三
```

这就是汇编了，机器语言和汇编语言一一对应。

# 硬件相关

## 大小端

大端模式，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；这和我们的阅读习惯一致。

小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。

## 给段偏移寻址擦屁股



## I/O端口读写

### 独立编址

* 优点：I/O端口地址码较短，译码电路简单，存储器同I/O端口的操作指令不同，程序更清晰；存储器和I/O端口控制结构相互独立，利于解耦和设计。
* 缺点：需要专用的I/O指令，程序灵活性略差

`outs`、`ins`、`out`和`in`

外设接口电路有专用于数据交互的寄存器。为了与CPU中的寄存器相区别，称之为“端口”。端口有数据端口，状态端口和控制端口3种。

PC机给予每一个端口分配了一个地址（称为端口号），形成一个独立于内存空间的I/O地址空间。在8086/8088中，端口地址的范围是0000至FFFF。

> IO地址空间：X86特有（独立编址），与内存空间彼此独立的地址空间，32位X86有64K的IO空间。
>
> IO端口：当寄存器或内存位于IO空间时，称为IO端口。

CPU对外设的操作通过专门的端口读写指令来完成。读端口用IN指令，写端口用OUT指令。

端口号可以是立即数，也可以是DX。

```assembly
IN AL,21H ;表示从21H端口读取一字节数据到AL
IN AX,21H ;表示从端口地址21H读取1字节数据到AL，从端口地址22H读取1字节到AH

MOV DX,379H
IN AL,DX  ;从端口379H读取1字节到AL

OUT 21H,AL ;将AL的值写入21H端口
OUT 21H,AX ;将AX的值写入端口地址21H开始的连续两个字节。（port[21H]=AL,port[22h]=AH）

MOV DX,378H
OUT DX,AX ;将AH和AL分别写入端口379H和378H
```

现代的硬件设备更倾向于映射I/O，处理器和I/O设备之间的通信就可以直接使用对内存进行操作的汇编语言指令，处理速度较快，并可以和DMA结合起来使用。

![](C:/Users/Five/Desktop/note/img/2749555-1G2011606295B.png)

### 统一编址

存储器和I/O端口共用统一的地址空间，当一个地址空间分配给I/O端口以后，存储器就不能在占有这一部分的地址空间。

* 优点：不需要专门的I/O指令，I/O端口地址空间可大可小，外设数量几乎不受限制。
* 缺点：占用了一部分内存，内存地址往往较长，执行时间会增加。

# 汇编器和工具链

主要的汇编器有GNU的汇编器AS（也是GCC默认汇编器）、MSVC的x86汇编器MASM、ARM的ARMASM，一些独立的汇编器NASM、YASM。[^2]

## NASM[^3]

The Netwide Assembler，遵循Simplified BSD协议

> the Netwide Assembler (NASM), an asssembler for the x86 CPU architecture portable to nearly every modern platform, and with code generation for many platforms old and new.

* 'a86'不错，但不是免费的，而且你不可能得到32位代码编写的功能，除非你付费，它只使用在dos上。
* 'gas'是免费的，而且在dos下和unix下都可以使用，但是它是作为'gcc'的一个后台而设计的，并不是很好，'gcc'一直就提供给它绝对正确的代码，所以它的错误检测功能相当弱，还有就是对于任何一个想真正利用它写点东西的人来讲，它的语法简直太可怕了，并且你无法在里面写正确的16位代码。
* 'as86'是专门为Minix和Linux设计的，但看上去并没有很多文档可以参考。
* 'MASM'不是很好，并且相当贵，还且只能运行在DOS下。
* 'TASM'好一些，但却极入与MASM保持兼容，这就意味着无数的伪操作码和繁琐的约定，并且它的语法本质上就是MASM的，伴随着的就是一些自相矛盾和奇怪的东西。它也是相当贵的，并且只能运行在DOS下。

### 基础用法

```cmd
nasm -f <format> <filename> [-o <output>]
```

若不指定`filename`nasm会自己根据`format`指定后缀名（如`.obj`、`.o`等），特别地，`bin`格式一般会去掉后缀名。

`-felf`和`-f elf`的用法都是合法的。同理，`-o filename`和`-ofilename`都是合法的。

### 更多用法

```cmd
nasm -f <format> <filename> [-o <output>] [-g] [-F] [-l [-Lflags]]
```

* `-g`生成debugging信息，`-F`指定debugging信息的文件类型。
* `-l`生成lst文件，`-Lflags`可调整输出的lst文件信息（后面的第一份代码有演示lst文件）

更复杂的用法等用到了再回来填坑。



#### dollar符

NASM提供标记`$`，等同于标号，可以看成一个隐藏在当前行行首的标号。

双dollar`$$`是NASM提供的另一个标记，代表当前汇编节（段）的起始汇编地址。



## GNU AS

GNU自带的汇编器

* `-ac`, omit false conditionals
* `-ad`, omit debugging directives
* 

* GNU Assembler Input and Output
* GNU Assembler Syntax
* Sections and Relocation
* Assembler Symbols
* Assembler Expressions
* Assembler Directives
* Acknowledgements
* History
* GNU General Public License
* GNU Free Documentation License
* Funding Free Software

* 



## Bochs

`s`（step）表示执行下一条命令。`c`（continue）表示不间断执行，直至断点。

`b`（break）表示设置断点，如`b 0x7c00`表示在处理器执行到地址`0x7c00`处的那条指令时停下来。

`r`（register）显示通用寄存器内容，`sreg`（segment register）显示段寄存器内容

`xp`（eXamine memory at Physical address）显示指定物理内存地址处的内容。每次只显示一个双字



## 为什么都说汇编比C快

对于CPU而言，在经过编译之后都是机器指令，自然一视同仁，总不可能汇编和C编译后同一条指令执行的CPU周期不一样吧？

总的来说，汇编直接和硬件打交道，而C处于通用性、易用性或其他方面的考虑，编译器往往需要加入额外的C语言代码来支撑，因此实际的代码量就变得很大。

C语言不用考虑切换栈、不用考虑用哪个段。





[^1]:《x86汇编：从实模式到汇编模式》
[^2]:汇编语言用什么编译器？ - dontpanic的回答 - 知乎 https://www.zhihu.com/question/386611444/answer/1142316409
[^3]:nasm官方文档https://www.nasm.us/xdoc/2.15.05/html/nasmdoc0.html
[^4]:《Computer System: A Programmer's Perspective》 Randal E. Bryant