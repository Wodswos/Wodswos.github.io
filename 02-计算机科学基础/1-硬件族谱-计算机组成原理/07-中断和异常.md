中断需求的诞生：

* 在加法器和乘法器的设计中，我们已经能够检测溢出的异常，但检测到了之后该如何处理呢？
* 要等上一个任务结束才能进行下一个任务，能不能有点交互性呢？

# 硬件的发展

1951年，UNIVAC，第一个带有异常处理的系统：算术运算溢出时，转向地址0执行两条修复指令，或者停机。

1954年，DYSEAC，第一个带有外部中断的系统：有两个程序计数器（PC），根据I/O信号进行切换

1976年，Intel的传奇中断控制芯片8259在就被用在8085系列产品中。

1981年，PC在出生时借鉴了这种思想，8259的升级版8259A被用于中断控制，而其统治PC长达近10年，直到486电脑的诞生。[^1]



# 中断

## 8086，永远滴神

在8086的存储器中保留两个专用区域

* 中断向量表区：00000H~003FFH（地址最低的1KB）
* 初始化程序区：FFFF0H~FFFFFH（地址最高的16B）



每个中断类型对应1个4字节的中断向量，所以整个中断向量表中一共可以有0到255共256个中断向量。

* 前（低）两个字节存放中断服务程序入口地址的偏移量（IP，小端模式）
* 后（高）两个字节存放中断服务程序入口地址的段基址（CS，小端模式）

![image-20210324193041982](C:\Users\Five\Desktop\note\img\image-20210324193041982.png)



8086中CPU固定使用了前5个类型的中断，之后的27个中断也保留给CPU使用，再之后的224个中断留给用户自定义。

* 类型0：除法错
  * 所得的商超出了目标寄存器所能表示的范围
  * 也叫除零中断，虽然这么叫，但不只除零会触发该中断
* 类型1：单步
  * 对应标志位TF，置1后CPU处于单步工作方式
  * 在单步工作方式下，CPU每执行一条指令就自动进行一次INT 1中断服务程序
  * INT 1中断服务程序内容一般为显示CPU内部各寄存器的内容和一些其他信息，以辅助调试工作。
* 类型2：非屏蔽
  * 由专门的CPU针脚NMI，通知CPU发生了灾难性事件
  * NMI线上中断请求是不可屏蔽的（无法禁止的）、而且立即被CPU锁存。
* 类型3：断点
  * 一种调试程序的手段，一般与单步配合使用
  * 所有`INT n`指令中只有`INT 3`是一条单字节的指令，其他都是两字节指令
* 类型4：溢出
  * 执行`INTO`指令时，若溢出标志位OF为1，则触发溢出中断
  * 一般将`INTO`指令跟在可能发生溢出的算术操作之后，如`ADD AX,BX`。
    * 若一切正常，则该指令啥也不干
  * `INTO`指令等同于`INT 4`指令



## 向量表到描述符表

在8086之后，新的中断类型被不断添加到中断向量表中。

* 类型6：未定义的操作码
* 类型7：协处理器不存在
* 类型8：双中断错
* 类型9：协处理器段超限
* 类型10：无效任务状态段
* ……



进入保护模式后，中断向量表和其他内容一样，其通过GDT被找到，故不再局限于00000H~003FFH的地址了，而是可以放在内存的任意地方。

中断向量表也升级为中断描述符表，每个中断描述符8个字节。

* 字节0、1为32位偏移量的低16位
* 字节2、3存放段选择符代替原来的段基址
* 字节4、5存放优先级等信息
* 字节6、7存放32位偏移量的高16位
  * 即第0、1、6、7字节组合得到EIP寄存器的值





## 内部中断和外部中断

外部中断也称为硬件中断、中断，内部中断也称为、软件中断、异常。

中断和异常，像双生子，也可以统称为异常或中断。



* 内部中断的类型号由CPU内部产生，外部中断则需要从外设读取中断类型号。
* 除了单步中断外，所有内部中断都不可以用软件的方式来屏蔽。
* 除单步中断外，所有内部中断的优先级都比外部中断高。



## 内部中断分类

![image-20210324212832421](C:\Users\Five\Desktop\note\img\image-20210324212832421.png)



除法错中断（INT 0）是被动触发的，而溢出中断（INT 4）需要在执行指令后用`INTO`等指令进行主动的检查

由硬件自己检测每一次的算术运算是否溢出，可能会带来性能的下降，所以决定将其控制权交给程序员。



前面提到了，所有`INT n`指令中只有`INT 3`是一条单字节的指令，其他都是两字节指令。

对于其他指令而言，一个字节是操作码，一个字节是编号，顺理成章，`INT 3`则有些特殊。

![image-20210324215312729](C:\Users\Five\Desktop\note\img\image-20210324215312729.png)







# 中断的处理

## 中断的检测

![image-20210324204032621](C:\Users\Five\Desktop\note\img\image-20210324204032621.png)

> Intel处理器规定，NMI中断信号由0跳到1后，至少要维持4个以上的时钟周期才算是有效的，才能被识别。

### 标志寄存器

标志寄存器中有状态标志和控制标志。

状态标志一般由硬件设置，软件读取；控制标志一般由软件设置，硬件读取。

* 对于可屏蔽中断请求，可通过IF标志位设置
  * IF=1，允许CPU响应可屏蔽中断请求
  * IF=0，不允许CPU响应可屏蔽中断请求
  * 和其他标志位类似，STI指令将IF置1，CLI指令将IF清零

![image-20210324205605611](C:\Users\Five\Desktop\note\img\image-20210324205605611.png)

## 中断处理流程

以下是一个大致的参考过程，不同的系统在软硬件上有着差异。

1. 发生中断，CPU内部产生中断信号

2. 识别中断源

   CPU识别中断来源，确定中断类型号

3. 保存断点

   将中断处的CS、IP、PSW等压入堆栈

   清楚IF标志位，关中断，不再响应其他的中断请求

4. 根据中断类型号找到对应的中断服务程序地址

5. 保存现场，执行中断服务程序

   将中断处的有关寄存器（中断服务程序会使用的寄存器以及标志寄存器）压入堆栈

   保护现场可以认为是中断服务程序的一部分

   并适当重新开放中断

6. 恢复现场并返回

   中断返回指令`IRET`，从栈顶弹出3个字，分别送入IP、CS和FLAGS寄存器

   在32位、64位中扩展为`IRETD`、`IRETQ`指令



## 外部中断处理

x86 CPU为外部中断提供两个引脚：

* NMI：Non-Masked Interrupt，非屏蔽中断
  * 比如电池没电
* INTR：INTeRrput，可屏蔽中断
  * 绝大部分外设的中断请求

### 中断控制器

CPU只有一个INTR的引脚，所以需中断控制器进行辅助工作。

![image-20210325153129739](C:\Users\Five\Desktop\note\img\image-20210325153129739.png)

典型的PIC（Programmable Interrupt Controller，可编程中断控制器）有Intel 8259A，提供8个中断请求的输入。



后来又有了APIC（Advanced Programmable Interrupt Controller），如82093AA

### 中断处理流程

![image-20210325154441286](C:\Users\Five\Desktop\note\img\image-20210325154441286.png)



## 中断嵌套

当CPU正在执行中断服务程序时，发生优先级更高的中断请求此时CPU响应优先级更高的中断请求，而将正在处理的中断服务挂起。

即低优先级的中断服务程序，对于高优先级的中断而言，就像一个普通的程序一样，处理过程也一样。

# 基于中断的功能调用



## BIOS中断

* BIOS各功能模块的入口地址都在中断向量表中
* 通过软件中断指令`INT n`调用各功能模块
* 如有需要，使用寄存器传递参数

![image-20210324220413704](C:\Users\Five\Desktop\note\img\image-20210324220413704.png)

## DOS中断

只占用了`INT 21H`一个中断类型号，但提供了非常丰富的服务。

包含文件管理、存储管理、作业管理和设备管理等功能。这些功能共用一个中断入口，通过传参数的方式设置功能号，从而执行不同的功能模块的代码。

DOS的中断功能比BIOS中断更齐全，进一步屏蔽了设备的物理特性。

![image-20210324220819394](C:\Users\Five\Desktop\note\img\image-20210324220819394.png)



## Linux中断

BIOS和DOS都是存在于实模式下的程序，由他们建立的中断调用都是建立在中断向量表中的。

计算机启动之初，BIOS会填写中断向量表的中断例程。

Linux内核是在进入保护模式后才建立中断例程的，此时由中断描述符表取代中断向量表。



Linux通过`int 0x80`指令进入一个中断程序后再根据eax寄存器的值来调用不同的子功能函数。





[^1]:《操作系统真象还原》郑刚
[^2]:计算机中断体系一：历史和原理 - 老狼的文章 - 知乎 https://zhuanlan.zhihu.com/p/26464793