如标题“从逻辑门到ALU”，本文是关于[Coursera](https://www.coursera.org/learn/jisuanji-zucheng/home)课程和如下问题的整理：

* CPU是怎么用逻辑电路实现算数运算的？
* 现代计算机（PC）的组成是怎么样的？

主要参考内容：

[Coursera](https://www.coursera.org/learn/jisuanji-zucheng/home)课程

[知乎高赞回答](https://www.zhihu.com/question/348237008)



# 加减法实现

## 半加器和全加器

![image-20201006192111868](C:/Users/Five/Desktop/note/img/image-20201006192111868.png)

用一个异或门得到当前位结果S，用一个与门得到进位C。

> 当且仅当其中一个为0，一个为1时当前位和为1，正好对应逻辑关系异或
>
> 当且仅当两个加数都为1时进位为真，正好对应逻辑关系与

但半加器能得到进位，却不能计算进位。因此需要将两个半加器组合，得到一个全加器。

即第一个半加器负责当前位的加法，第二关半加器负责处理可能存在的进位。最终的得到总的结果。

![image-20201006192405053](C:/Users/Five/Desktop/note/img/image-20201006192405053.png)



进一步，多个1-bit Full Adder串行，就形成了简单但完整的加法器。

![image-20201006192427460](C:/Users/Five/Desktop/note/img/image-20201006192427460.png)

同理可构建16、32位加法器。

![image-20210323195022143](C:\Users\Five\Desktop\note\img\image-20210323195022143.png)

图中两条指令`add`和`addu`的不同在于对溢出的处理。

## 异常处理：溢出和进位

溢出和进位一般来说都是计算结果超出了数据类型的表示范围。

**溢出，Overflow，仅仅是针对有符号数而言的。**

对于无符号数而言，它的“溢出”是丢弃了进位，相当于一次模操作——至少是比较好理解的。所以可以称之为进位，而不是“溢出”。

![image-20201006192915671](C:/Users/Five/Desktop/note/img/image-20201006192915671.png)

而真正的溢出，应该说是由有符号数特殊的编码方式——补码造成的，所以可以尝试从补码的角度分析问题。

![image-20210323200427442](C:\Users\Five\Desktop\note\img\image-20210323200427442.png)

以上是有符号数（补码）每一位的权值分布，从中也可以发现溢出的本质：

* 两个权值$2^{n-2}$次的位为1的数（也可能是借助进位），相加后却给权值为$-2^{n-1}$的位进了一位
  * 表现为两个正数相加得到一个负数
* 两个权值$-2^{n-1}$的位为1的数（也可能是借助进位），相加后的进位被忽略了
  * 表现为两个负数相加得到一个正数

下图来自《CS: APP》

![image-20210413151726582](C:\Users\Five\Desktop\note\img\image-20210413151726582.png)

对于底层硬件而言，它可不知道也不在乎你给的输入是不是有符号数，它只管傻乎乎地用那一连串的全加器进行计算。

所以对于第二种情况的溢出，硬件的感受和无符号数的进位一样，也可以通过最高位全加器的进位输出进行判断，给出提示。而对于第一种情况的溢出，硬件可能就完全就意识不到问题的严重性，还搁那庆祝计算完成呢。

所以该如何全面检查有符号数的溢出呢？也简单，如下图所示：

![image-20201006193242110](C:/Users/Five/Desktop/note/img/image-20201006193242110.png)

MIPS中，`add`、`addi`指令将操作数看作有符号数，溢出时产生异常。`addu`、`addiu`指令（u即unsinged）将操作数看作无符号数，不处理溢出。

x86中，没有区分两种指令，它在标志位中设有OF（Overflow Flag，标志寄存器第11位），若发生溢出则置为1.

## 减法运算

### 减法和负数

对于计算机而言，减法是加法的特殊形式，即加一个负数（的补码），或者说就是有符号数的运算。

而这个负数的补码可以通过对其绝对值进行按位取反，末位加一得到。

所以$A-B=A+(-B)=A+(\bar B + 1)$

### 减法运算实例

添加一个sub-mode的信号，当该信号为1时，表示进行减法。

此时选择器也会选择数字B经过一个非门后形成的输入作为输出（按位取反），而同时sub-mode的信号作为进位输入传递给最低位的全加器（末位加一），巧妙而精致。

![image-20201006193608328](C:/Users/Five/Desktop/note/img/image-20201006193608328.png)



## 加法器优化——超前进位

RCA，Ripple-Carry Adder，行波进位加法器。

* 布局简单，设计方便。
* 高位的运算必须等待低位的运算完成，延迟时间长。

### RCA的关键路径长度

![image-20201006194024706](C:/Users/Five/Desktop/note/img/image-20201006194024706.png)

这是仅仅是对于4bit RCA的延迟，对于32bit RCA的延迟更高达65T.

> 这还是因为所有位的A、B都已给出，所以能早早并行计算完所有位的$A\oplus B$，只需等$C_{in}$到达，然后经过两个门延迟得到$C_{out}$，不然得要三个延迟。

很显然，进位输出信号拖了后退。

### 超前进位加法器

在RCA中，我们通过类似$C_{out} = [(A \cdot B) + (C_{in} \cdot (A\oplus B))]$的命题公式得到进位输出。

括号的嵌套程度说明了其串行程度，当然因为A、B已经早早给出，所以若括号内只有A和B的运算，可以早早并行计算完，所以可以忽略其带来的串行和延迟（与32bit的串行相比）。

既然所有位的A、B都已给出，那我们能不能进一步利用已经给出的$A_i,B_i$，并行计算出更多有用的信息呢？

我们可以对该命题公式进行等值演算，得到
$$
\begin{align}
C_{i+1} & = (A \cdot B) + (C_{in} \cdot (A\oplus B)) \\
& = (A_i \cdot B_i) + (A_i \cdot C_i) + (B_i\cdot C_i) \\
& = (A_i \cdot B_i) + (A_i + B_i) \cdot C_i
\end{align}
$$
因为无论i等于多少，$A_i,B_i$都是一开始就给出的，所以32个全加器（以32位为例）的$A_i+B_i$和$A_i \cdot B_i$也都可以同时并行计算。

为了方便，记$G_i = A_i \cdot B_i$，$P_i = A_i + B_i$，则有$C_{i+1} = G_i + P_i \cdot C_i$。

初看好像没什么优势，还是要两步走。但放到全局，递归嵌套，情况就不一样了。

![image-20201006194345166](C:/Users/Five/Desktop/note/img/image-20201006194345166.png)

对于四位的加法器，原来最拖后腿的、需要9个门延时的$C_4$进位的计算，此时只需要三个门延时（计算所有的$P_i,G_i$一个延时，计算所有与逻辑一个延时，计算或逻辑一个延时）。

而且因为$C_3$同理也只需要3个门延时，所以第四个（最后一个）全加器的s也可以得到更快的计算——总共四个门延时。

所以整个4bit加法器一共只需要4个门延时，提升了一倍有余。

> 当然，从$C_4$的表达式就能感受到电路的复杂性了。

这就是超前进位加法器，Carry-Lookahead Adder，CLA。

![image-20201006194505011](C:/Users/Five/Desktop/note/img/image-20201006194505011.png)

![image-20201006194530818](C:/Users/Five/Desktop/note/img/image-20201006194530818.png)



对于更高位的加法器，通常采用多个小规模的超前进位加法器拼接，如用4个8-bit的超前进位加法器连接成32-bit加法器。



#### 为什么可以

等老子学通了并行计算再回来填坑。



### 一个实际的例子

麒麟9000芯片是华为公司于2020年10月22日20:00发布的基于5nm工艺制程的手机Soc，采用1*A77，3*2.54GHz A77，4*2.04GHz A55的八核心设计，最高主频可达3.13GHz。

# 乘除法实现

## 从十进制到二进制

> ENIAC采用十进制，EDVAC采用二进制，两者电路的复杂度有巨大的差别。
> 
> 虽然理论上e进制最优，但显然无法实现；整数进制3最优，但也很难实现。二进制既有效率，又契合工程设计。
>
> 《EDVAC的报告草案》：
>
> 1. 电子管是一种“全或无”的设备，适合表示只有两个数值的系统，即二进制。
> 2. 二进制可以大幅简化乘法和除法的运算过程，不再十进制乘法表，也不再需要两轮加法。
> 3. 但十进制更适合人使用，所以输入输出设备应当承担二进制和十进制的转换工作。

![image-20201016162226769](C:/Users/Five/Desktop/note/img/image-20201016162226769.png)



同时，因为寄存器是很有限的，产生所有的中间结果，然后累加出结果——这样的计算过程适合人，但并不适合计算机。

所以需要对运算过程进行调整：将乘积初始值设为0，每产生一个中间结果，直接将其累加到乘积上，然后重复过程直到乘数的每一位被计算完成。



## 乘法器的实现

![image-20201016175648385](C:/Users/Five/Desktop/note/img/image-20201016175648385.png)

其中Multiplicand表示第一个乘数（被乘数），Multiplier表示第二个乘数

1. 若Multiplier当前最低位为1，则Product+=Multiplicand
2. multiplier>>1并补0, Multiplicand<<1并补0
3. 若Multiplier全为0（循环次数=Multiplier位数），运算结束，否则回到步骤1继续循环

![image-20201016175526371](C:/Users/Five/Desktop/note/img/image-20201016175526371.png)

流程图如下所示（我也想用markdown画一下，但是mermaid的流程图确实有点丑，flow又有点繁琐，就直接贴截图了）：

![image-20201016175720056](C:/Users/Five/Desktop/note/img/image-20201016175720056.png)



以下内容为个人的叨叨，可以跳过。

> 可以理解为在乘法运算中并没有“乘法”，乘法是移位和加法两种操作的结合。
>
> 或者换个角度说，我们很容易发现，对于乘2，只需左移一位，低位补0即可（所以C++/Java中乘2、4等操作往往推荐使用位运算<<），同样，对$2^n$乘法都是仅需左移n位。
>
> 那乘3这种呢？很简单，用左移1次的数+左移0次的数。
>
> 那乘n呢？只需将n拆分成$k_02^0+k_12^1+...+k_m2^{m}$的形式，显然$k_i\in{0,1}$，若$k_i$为1，则总乘积加上左移$i$次的数，最后累加的就是结果。
>
> 这些$k_0,k1,...,k_m$反向排列起来$k_m..k_1k_0$是什么呢？其实就是另一个乘数的二进制。
>
> 绕了那么大弯，算是对乘法器的另一种理解角度。只想借此说明乘法是移位和加法的结合，或者不准确的说，移位才是计算机乘法（一种不完全的乘法）的核心。
>
> 不然粗暴地算，乘N就是累加N次，那不是要累死？位移降低了计算复杂度，即累加次数变为了N的二进制数的位宽。

### 补码乘法运算的正确性

可以垂阅……也记不清具体哪一篇笔记了，反正写过。



### 符号扩展

两个w bit的二进制数得到一个不超过2w bit的二进制数。

在这个乘法运算过程中，有一步比较容易被忽略：w bit的二进制数扩展为2w bit，高位补符号位，即符号扩展。

这点在无符号数中影响不大（也因此真的被忽略），反正都是补0。但在有符号数的运算中，即补码运算中，负数高位要补1（符号位）。



## 乘法器优化

### 可以并行的操作

对于最原始的乘法器，计算一个32位的乘法需要约100个时钟周期。

> 时钟上升沿到来之前，寄存器内容不会发生变化

乘数寄存器右移、被乘数寄存器左移、乘积寄存器保存ALU计算结果三步操作可在同一个时钟周期内并行完成。

![image-20201016181848643](C:/Users/Five/Desktop/note/img/image-20201016181848643.png)



### 减少不必要的硬件资源

> 看这部分优化的感受是：做硬件的人的确是非常抠了……

* 被乘数占用的位宽=被乘数位宽+乘数位宽，而不是被乘数的有效位宽，存在冗余
* 乘数寄存器占用的位宽会随运算进行右移而减少，但没能被利用
* 乘积寄存器初始存在与被乘数占用位宽类似的问题，即刚开始不需要那么多位宽
* 加法器实际参与运算的是4位而不是8位（以1000*1001为例）

对应优化方案

* 去掉被乘数左移的功能，使之固定位置，从而也固定位宽，还省了左移的过程
  * 但会产生ALU两个加数对齐的问题
* 直接取消乘数寄存器
  * 乘数放哪里呢？
* 对乘积寄存器不做删减
  * 但需要增加功能解决前两个寄存器优化的问题，能力越大，责任越大嘛
    * 解决被乘数左移功能删减带来的对齐问题——被乘数不左移，让乘积右移
    * 放置乘数，初始置于乘积寄存器的低四位
* 乘积寄存器只有高四位参与运算，被乘数也只有四位，所以只需要四位加法器

![image-20201016185719705](C:/Users/Five/Desktop/note/img/image-20201016185719705.png)

同样可以推广到N位的乘法器：

![image-20201016185803585](C:/Users/Five/Desktop/note/img/image-20201016185803585.png)



## 除法运算

### 带余数的除法器

![image-20201016194224115](C:/Users/Five/Desktop/note/img/image-20201016194224115.png)

![image-20201016195330026](C:/Users/Five/Desktop/note/img/image-20201016195330026.png)

当然，在日常中我们可以直接比较大小，决定是否要减去除数，而不用在减完之后回退。

但在计算机中，大小的比较恰恰就是通过减法结果的正负来实现。



![image-20201016201345177](C:/Users/Five/Desktop/note/img/image-20201016201345177.png)

### 除法器的优化

* 与乘法器相似，去除商寄存器、除数寄存器的移位，让余数寄存器去实现
  * 余数寄存器只有高32bit参与加减法运算
  * 将商放入余数寄存器的低位
    * 计算结束后高32位为余数，低32位为商

![image-20201016202147466](C:/Users/Five/Desktop/note/img/image-20201016202147466.png)



# 浮点数运算



> 关于浮点数
>
> 在十进制中，小数可以视为$k_1*10^{-1}+k_2*10^{-2}+...+k_n*10^{-n},k_i\in\{0,1,2,..,9\}$
>
> 同理，小数在二进制中也可以视为$k_1*2^{-1}+k_2*2^{-2}+...+k_n*2^{-n},k_i\in\{0,1\}$
>
> 当然，在十进制中的有限小数比如0.3，在二进制中就不能被精确表示了，而是一个无限循环小数，形如$0.0\dot100\dot1$。（天可怜见，初中的知识我应该没记错）
>
> 但二进制能精确表示，十进制都能精确表示，毕竟$2^{-n}$在十进制中都是有限小数。（三进制里能精确表示的十进制就hold不住了，$3^{-n}$不是有限小数。）







