![image-20201206154652045](C:\Users\Five\Desktop\note\img\image-20201206154652045.png)

冯诺依曼《关于EDVAC的报告草案》：

* 存储程序，而不是开关连线
* 二进制，而不是十进制
* 明确计算机五个部分
  * 运算器、控制器、存储器、输入设备、输出设备



| 冯诺依曼结构       | 现代计算机                              |
| ------------------ | --------------------------------------- |
| 运算器CA和控制器CC | CPU，Central Processing Unit            |
| 存储器M            | 主存储器（内存），与CPU通过系统总线连接 |



# 冯诺依曼结构的简化模型

![image-20201001142829334](C:/Users/Five/Desktop/note/img/1-14.png)

> 图中代表数据流向的箭头很细致，有些单向，有些双向
>
> 如MAR只向下传递，X，Y只进不出（对于总线，对ALU还是出的）

* 存储器
  * 存储单元的地址是唯一的，不同存储单元地址互不相同
  * 存储单元的位宽由设计计算机时对存储器的编码方法确定。如按字节编址，则位宽为8.
  * 总线
    * 地址总线的宽度为N，则CPU管理的存储单元最多为$2^N$个
    * 数据总线的宽度一般为存储单元位宽的整数倍
      * 毕竟存储单元位宽一般是传递信息的最小单位
  * MAR，Memory Address Register，存放CPU访问的地址
  * MDR，Memory Data Register，存放即将和CPU交互的数据
* 控制器
  * IR: Instruction Register，指令寄存器，存放正在/即将执行的指令
  * PC: Program Counter，程序计数器，下一条指令的存储地址
  * MAR/MDR同存储器MAR/MDR功能，两边通过总线交换信息
  * 指令译码，对IR中的指令进行译码，确定IR中存放的是哪一条指令
  * 控制电路，产生控制信号，在时序脉冲的同步下控制各个部件动作
* 运算器
  * 算术运算和逻辑运算
  * ALU，Arithmetic Logical Unit，算数逻辑单元
    * 之前所有的篇幅所描述的，大概就算是一种粗糙的ALU
  * F(flag)存放运算结果的状态：零/进位/溢出等
  * R0-Rn-1，通用寄存器，可以来自于存储器、其他通用寄存器、ALU输出等



## 计算机控制和运算

### 指令操作实例

![image-20201001153449775](C:/Users/Five/Desktop/note/img/1-15.png)

> 这种指令格式中默认第一个操作数既是源操作树，又是目标操作数，即结果会更新到寄存器R0

1. 取指
   1. 控制器将指令送往存储器
      1. PC寄存器中存储的内容通过内部总线传输到控制器MAR
      2. 控制器的MAR再通过地址总线传输到存储器MAR
      3. 同时向存储器控制逻辑发送指令，表示这波要读数据
   2. 存储器按给定的地址读出指令内容，送回控制器
      1. 通过地址译码器查找到内容放入存储器MDR
      2. 存储器MDR通过数据总线送入控制器MDR
   3. 控制器MDR将指令送往IR单元（还要记得更新PC单元中的内容，以便下一次操作）
2. 译码
   1. 根据IR中的指令编码做该做的事
3. 执行
   1. 找地址为6的存储单元，过程与取指类似，最终送入Y寄存器。
   2. 将R0寄存器内容放入X寄存器
   3. 计算出结果Z
4. 回写
   1. 将Z寄存器的结果放入R0寄存器

进行下一条指令。重复。



## 计算机的输入输出

在冯诺依曼结构中，其实除了输入I/输出O，还定义了R: Outside Recording Medium，早期的穿孔纸带和现在的硬盘，都可以视为R。



> 寄存器和内存本质上都是电路（虽然读写速度差异巨大），存储的是电平，所以断电数据会消失。
>
> 与前两者不同，磁盘/硬盘不是半导体器件，保存的也不是电平，而是磁粉在物理层面的写入/擦除，断电数据自然不会消失。



### 在模型机上添加输入输出设备

> 牛郎星8800，内置Intel8080存储器和256字节存储器。
>
> 该计算机通过面板提供简单的输入输出。
>
> 乔布斯在此基础上进行改进，得到苹果I型的产品。

![image-20201001162227415](C:/Users/Five/Desktop/note/img/1-16.png)

以牛郎星面板为例的简单的输入输出——开关和小灯泡的亮灭。

![image-20201001162754367](C:/Users/Five/Desktop/note/img/1-17.png)

对于总线而言，“存储器”和“输入输出”就像是同一局域网下的两个不同主机，地址总线通过不同的指令（类似局域网下不同主机不同的IP），即可从不同的地方获得信息。



> 也就是说如果人类能像操作键盘、鼠标一样操作内存，那么存储器/内存就是输入输出，两者是一样的呗。
>
> 可惜人类当然不可能操作内存，再或者说只能绕个弯子通过输入输出去操作内存。



当然会有越来越多的输入输出设备。甚至对于高性能的显示等还需要显卡（黄老板发家地）等独立芯片进行交互。

![image-20201001163409076](C:/Users/Five/Desktop/note/img/1-18.png)

## 冯诺依曼结构和现实的对照

### Intel4004

名为4004，因为它还有一帮好兄弟4001/4002/4003

![image-20201001132223313](C:/Users/Five/Desktop/note/img/1-12.png)

![image-20201001132353531](C:/Users/Five/Desktop/note/img/1-11.png)

![image-20201001164234389](C:/Users/Five/Desktop/note/img/1-19.png)

### 现代PC

> 南北桥结构
>
> 北桥：访问通道
>
> 南桥：集成了主要的输入输出设备。

![image-20201001164415536](C:/Users/Five/Desktop/note/img/1-20.png)

> 计算机启动第一步——BIOS芯片
>
> 断电后内存（RAM，Random Access Memory）中是没有信息的，所以显然不能从内存读。
>
> BIOS是一块ROM，Read-Only-Memory，只读存储器，断电内容不会消失。



PC结构依旧再不停地演变，南北桥结构也逐渐被抛弃。（从PC端到移动端的变化更是大）

![image-20201001164531804](C:/Users/Five/Desktop/note/img/1-21.png)



### SoC-System on a Chip

系统芯片，将计算机和其他电子系统集成为单一芯片的集成电路。

> 使得智能手机等移动端设备成为可能



## 其他计算机结构

### 哈佛结构

别误会，下图表示的是冯诺依曼结构，不是哈佛结构

![image-20201001134050495](C:/Users/Five/Desktop/note/img/1-13.png)



之前提到冯诺依曼结构也称存储程序式计算机，好比餐馆将任务单和原料放在一起，而哈佛结构的不同，就是任务单（指令）不与数据放在一起，仓库-主存只存放原料-数据，指令通过另外的设备输入。

哈佛结构认为CPU应该分别通过2组独立的总线来对接指令和数据，而冯诺依曼结构认为CPU通过1组总线来分时获取指令和数据即可。



> 可能哈佛结构更贴近现实生活，任务单往往是通过经理、客人指定，而不是和原料一样放在仓库。
>
> 由此也能看出一些计算机和现实在空间和时间的尺度差别，度变了，更适合的架构也就变了。



# A Detailed Example[^1]

> 题外话，以下图片是从《Computer System A Programmer's Perspective》电子版（从z-library下载的）中截的。
>
> 这PDF是真的精致，一千多页的文档只有4.2M，还有很多配图。
>
> * 很精美
> * 所有图（起码几百张还是有的）加起来也一共才占0.6M
>   * PDF文档体积4.2M减去3.6M的ASCII字符
> * 放大也不会失真
>
> 应该是精心绘制的矢量图（不知道Latex可不可以绘制，反正俺不会），我这截图之后变成位图，每个图就要0.2M，放大还会失真。

![image-20201207112113516](C:\Users\Five\Desktop\note\img\image-20201207112113516.png)

## 加载





![image-20201207114341650](C:\Users\Five\Desktop\note\img\image-20201207114341650.png)

## 执行







## 输出



![](C:\Users\Five\Desktop\note\img\image-20201207114418128.png)









![image-20201207114442247](C:\Users\Five\Desktop\note\img\image-20201207114442247.png)



# 计算机早期发展编年史

* 电子管时代到晶体管时代1947-1958
  * 1947年，在贝尔实验室诞生第一只晶体管。
  * **1948年，香农发表《通讯的数学原理》，次年发表《噪声下的通信》**
    * 不足三十岁的香农成为了信息论奠基人。
    * 想想自己奔三了还是个小废物。
  * 1950年，东京帝国大学的Yoshiro Nakamats发明了软磁盘，开辟了存储新纪元。
  * 1951年，第一台UNIVAC交付美国人口普查局。
    * 1952总统选举，UNIVAC参与统计选票，最先准确预测结果，一夜成名。
  * **同年，图灵发表《机器能思考吗》，为人工智能奠定基础**。
  * 1952年，冯诺依曼设计的IAS电子计算机EDVAC问世，仅2300根电子管，却有ENIAC 10倍算力。
  * 1954年，IBM发布第一台电子计算机IBM701。
    * 1955年，IBM占据70%的市场。
  * 1956年，达特莫斯会议，首次提出人工智能的术语。
  * 1956第二代晶体管计算机发明。
  * 1965年，摩尔提出"摩尔定律，预言集成电路复杂度的指数级生长能力。
    * 现在（广义提及的）摩尔定律大概是快废了。
    * 不过摩尔当初提出的是指集成电路的复杂度，而不是现在通常说的价格不变、晶体管数目翻倍。
      * 从PC到移动端，集成度更高了，符合原始摩尔定律，但性能并没有质变。
  * 1968年，IBM最后一款电子管计算机IBM709.
    * 虽然是晶体管时代，但好像还是以电子管为主？
* 集成电路时代1959-1970
  * 1958年，集成电路（IC）问世，将电子元件结合到小小的硅片上。
  * **1964年，IBM公司研制成功第一个采用集成电路的通用电子计算机系列——IBM360**
    * IBM历史上最成功的机型
    * IBM360团队的Brooks基于开发实践写下《人月神话》奠定了软件工程基础
  * 1968年，又是从电子黄埔军校——仙童公司出来的一拨人创立了Intel
  * 1969年，又又是仙童出身的桑德斯，创立了AMD
* 微处理器——大规模集成电路时代1971-1979
  * 1972年，领导开发Unix的Dennis Ritchie领导开发出C语言
  * 1973年，鲍勃·梅特卡夫组件第一个局域网络，命名以太网
  * 1974，Intel推出第一款8位微处理器芯片8080
  * 1975，比尔盖茨退学创办微软公司。
  * 1976年，乔布斯和沃兹尼亚克共同创立了苹果公司
    * **现代计算机的巨头差不多到齐了吧。**
    * Google等互联网公司又是另一波浪潮了。
* PC时代——至今
  * 1980年，发布以太网技术规范。
  * 1982年，Intel发布80286，时钟频率20MHZ，增加保护模式
  * 1983年，IBM退出IBM PC/XT，内置硬盘
  * 1985年，Intel 80386处理器
    * Intel公司第一枚32位处理器
  * 同年，微软推出Windows操作系统。
  * 后续都是比较现代的事了。



[^1]:《Computer System A Programmer's Perspective》