# 电子电路

所有的电子电路只有两种目的（即所有EE专业的内容只有两部分）：信息处理，能量转换。

* 模拟电路：用连续的模拟电压/流值来表示信息
* 数字电路：用离散的电压序列来表示信息



## 模拟电路和数字电路

电路本身没有数字和模拟之分，区别在于处理的信号不同。

所以，同样的一个看似简单的`CMOS inverter`，由于输入信号不同，当数字电路使用时可被称为反相器，当模拟电路使用时又可以被称为`class AB amplifier`。



## 分层、复用、模块化

![](C:\Users\Five\Desktop\note\img\ic-layer.png)



### 接口

良好的接口设计可以使得模块之间相对独立、具有良好的扩展性、对技术变化的适应性等等。




# 信息和编码

## 信息

resolve 不确定性.

### 香农信息论



## 编码

编码代表的是特定事物。

## 码制

即编码的规则。数字电路中都采用二进制。（虽然理论上e进制最优，但显然无法实现；整数进制3最优，但也很难实现）

* 表示数量时称二进制
* 表示事物时称二值逻辑

> 十进制编码有8421码、余3码、2421码、5211码、余3循环码等。
>
> 最常规的8421码，其两个数值相加的结果可能不落在8421码内（即可能没进位，而是落在空余的编码位置上，如10-15），余3码可以解决这个问题。



### Unicode

详见个人博客其他文章。

### 变长编码

最典型的就是哈夫曼编码。但当数据分布（足够）均匀的时候，哈夫曼编码也会退化到等长编码。

### 正负和补码的实质

> 第一次见到补码难免觉得又奇怪又神奇，不那么直观却真的work。

在原码中，带符号数常用最高位为`1`表示负数，最高位为`0`表示正数。

但此时，无法用无符号加法器直接进行加法操作，比如`10+(-10)`，即`101010+001010`，用无符号加法器会得到`100100`，即`-4`，这显然不正确。

（还有出现`+0`和`-0`，造成编码浪费）

这些	错误是由于编码“不当”（`负`编码为`1`，`正`编码为`0`）造成的。

带符号的数制可以理解为一种混合编码，后面的bit编码的对象是数值（用数值编码数值，也可以理解为没编码），第一个bit编码的对象是事物（正负）。

于是补码应运而生。

补码的实质：对于$n$位数，$1,2,\dots, k,\dots,n-1$位表示$2^k$，但第$n$位（最高位），表示的是$-2^n$。

所以对于$n$位带符号整数，其正数最多能编码$2^0+2^1+\dots+2^{n-2}=2^{n-1}-1$个，而负数是$2^{n-1}$个（比正数多一个）。正负数加起来，再加上一个$0$，一共是$2^n$个，符合$n$位二进制能编码的数量。

再所以，如$-1$的补码一般形如$\underbrace{11\dots11}$（$n$个1）。

对补码进行加法操作，神奇的事情发生了，正数和负数的加法能用无符号加法器直接正常计算了。

如果正数绝对值小于负数，那么还为负；如果正数绝对值大于负数，会造成一次“溢出”，恰恰是这次溢出，使得数值重新为正了



#### 补码和原码的转换

* 最高位代表符号位，不变
* 正数的补码和原码相同
* 负数的补码 = 原码按位求反+1 （如果是小数，+1加在末位，而不是0权位）

正数和负数的扩展都是直接在前面填充符号位（正数比较好理解，负数要转个弯）

> 同理，当一个数（补码）前面是连着的`1`或`0`，说明这个数前面的一串`1`和`0`可以缩为一个。



