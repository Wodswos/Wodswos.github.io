

![流水线寄存器](C:\Users\Five\Desktop\note\img\image-20201215183035645.png)

# 流水线



![时间性能分析](C:\Users\Five\Desktop\note\img\image-20201215183323672.png)



## 流水线的平衡性

每一级流水线都需要以执行时间最长的一个阶段的用时为周期，所以每一阶段的执行时间要尽可能平衡。





## 超级流水线

超流水线（superpiplined）是指某型CPU内部的流水线超过通常的5~6步以上



### 流水线深度变化

![流水线深度变化](C:\Users\Five\Desktop\note\img\image-20201215184406645.png)





## Intel CPU架构[^1]

2008年，Nehalem Pipeline

![image-20210413094351017](C:\Users\Five\Desktop\note\img\image-20210413094351017.png)





2011年，Sandy Bridge Pipeline

![image-20210413094150731](C:\Users\Five\Desktop\note\img\image-20210413094150731.png)





2013年，Haswell Microarchitecture

![image-20210413094002650](C:\Users\Five\Desktop\note\img\image-20210413094002650.png)

2015年，Skylake Microarchitecture

![image-20210413094450185](C:\Users\Five\Desktop\note\img\image-20210413094450185.png)





# 流水线的冒险

> 我们在试图理解流水线的动作时，不要将关注点放在逻辑电路上，而要将关注点放在寄存器值的变化上。因为组合逻辑电路不受时钟信号影响，仅负责信号的传播，真正依赖时钟信号的是寄存器的写入行为。我们的目标便是寄存器的值随着时钟周期发生正确的变化。[^2]

Hazard，冒险，阻止下一条指令在下一个时钟周期开始执行的情况

* 结构冒险：所需的硬件部件在为之前的指令工作
* 数据冒险：需要等待之前的指令完成数据的读写
* 控制冒险：需要根据之前指令的结果决定下一步的行为

## 结构冒险

情况1：

![流水线中指令和数据读写冲突](C:\Users\Five\Desktop\note\img\image-20201215195135500.png)

* 解决方案1：流水线停顿，产生空泡
  * 很显然，停顿是所有冒险的一种通用处理方式，但会带来比较明显的效率下降
* 解决方案2：在高速缓存中分开存储指令和数据

情况2：

![寄存器堆读写冲突](C:\Users\Five\Desktop\note\img\image-20201215195335679.png)

> 寄存器堆的读写速度较快，如读写寄存器的延迟可能为100ps，ALU等部件的延迟可能为200ps。

前半个时钟周期写，后半个时钟周期读，并且设置独立的读写口。



## 数据冒险

![image-20201215195527259](C:\Users\Five\Desktop\note\img\image-20201215195527259.png)

* 解决方案：流水线停顿。
  * 没法并行（两次计算之间有依赖），也没法预测执行（32位寄存器有$2^{32}$种值，咋预测），显然只能停顿。

![image-20210413102915947](C:\Users\Five\Desktop\note\img\image-20210413102915947.png)

由软件来产生nop指令终究不合适，毕竟不同处理器的流水线深度也不一样，需要的nop指令数量也不同。

同一段代码在5级流水线能正常执行，到了更深的流水线就会出错。所以更好的方法是由硬件自己来产生nop指令，即空泡。



### 前递和旁路

前递是从指令执行顺序的角度描述，旁路是从电路结构的角度描述。

![image-20210413104022580](C:\Users\Five\Desktop\note\img\image-20210413104022580.png)

当然，前递和旁路不止能应用于这样一个场景。



### Load-Use Hazard

一条指令需要使用之前指令的访存结果。

![image-20210413104908850](C:\Users\Five\Desktop\note\img\image-20210413104908850.png)

解决方案：流水线停顿+数据前递

## 控制冒险

![未确定分支](C:\Users\Five\Desktop\note\img\image-20201215195707113.png)



转移指令在程序中所占比例约为15%~25%。

对于更深的处理器，转移指令带来的周期损失更大。

![image-20210413105421316](C:\Users\Five\Desktop\note\img\image-20210413105421316.png)

### 转移指令

![image-20210413105830175](C:\Users\Five\Desktop\note\img\image-20210413105830175.png)



* 无条件直接转移
  * j Target
  * New PC = { (PC + 4)[31..28], address, 00 }
* 无条件间接转移



### 延迟转移

![image-20210413111418679](C:\Users\Five\Desktop\note\img\image-20210413111418679.png)





### 分支预测

最简单的动态分支预测策略是分支预测缓冲区（Branch Prediction Buff）或分支历史表（branch history table）。



# 超标量流水线

具有两条或两条以上并行工作的流水线结构称为超标量结构。与之相对，之前的流水线称为“标量流水线”。

在一个时钟周期内，可以同时发送两条或以上指令。

## 超标量流水线和多核CPU





### Pentium

Pentium是第一款超标量x86 CPU。双发射，5级流水线。

每条流水线都有自己的地址生成逻辑、ALU及Cache接口。



[^1]:《64-ia-32-architectures-optimization-manual》
[^2]:https://www.cnblogs.com/niuyourou/p/11907858.html