选择和冒泡就不提了。

插入排序：往已排序的数组（当然也可以是空的数组）中，逐个加入待排序的数组。具体实现上可以如下（在原数组上直接操作，而不是真的新开一个数组）：

```c
for j=2 to A.length:
    key=A[j]
    //将A[j]插入已排序序列A[1..j-1]
    i=j-1
    while i>0 and A[i]>key
        A[i+1]= A[i]
        i=i-1
    A[i+1]=key
```



# 快排



## 小技巧：双指针

虽说是双指针，但实战中也许还可以是三指针，四指针等等。

快排、归并，都有双指针的思想蕴含其中。

# 归并







# 二分查找

很显然对于有序数组的查找，一般都是二分查找。

## 递归和循环

所有递归都可以改写成循环吗？ - pansz的回答 - 知乎 https://www.zhihu.com/question/20418254/answer/17065965



## 二分Plus

> LeetCode第四题，求两个有序数组的总的中位数

暴力解法自然是归并。

但也可以用二分查找，经典的二分查找如下

```python
# 下述代码严谨性可能有待商榷，但不重要
# 也有递归的写法
def binarySearch (arr, x): 
    head = 0
    tail = len(arr) - 1
    while head < tail:
        mid = head + (tail - head)//2
        if arr[mid] == x: 
            return mid 
        elif arr[mid] > x: 
            tail = mid - 1
        else: 
            head mid + 1 
	return False
```

对于LeetCode第四题，设array1的长度为length1，array2长度为length2。观察下图（图源LeetCode官方），观察并比较“归并”前后，

![](C:/Users/Five/Desktop/note/img/e7d69e5b6c9e543ab0019eeb8e69740c12b4c6e7af409c62ff600bd96425302f-4_3.png)

对于length1 + length2为偶数的情况，可知存在点x和y（或者说mid1和mid2）满足

* x<lenght1，y< length2
* x+y=(length1 + length2)/2 + 1
* x后面的数比y前面的数也都大，y后面的数也比x后面的数大。

而二分查找要找的，就是这个x和y。代码如下

```python
```



可以发现就是原来二分查找代码进行了一次类似“双指针”的升级。length1 + length2为奇数的情况类似。

