# 树

首先，所有的数据结构在数学上都是图，或者说是具有某种特殊性质的图，树自然也不例外。

树是不包含简单回路的连通图。

> 树 = 不包含简单回路的连通图 = 最小连通图 = 最大无回路图







## 树、森林、二叉树

> 俺不知道这些内容在实践中会有多大的用处，但考研会考，我tm卷起来了，我堕落了。

从普通树到二叉树的转化

* 父节点只保留与第一个子节点的连线，兄弟节点间加线

  * 意味着原有的右孩子删光
  * 除了一堆兄弟节点中除了第一个都会在转化后的二叉树中变成一个右孩子节点

  * 这种方法根节点永远没有右子树

![](C:/Users/Five/Desktop/note/img/20130916192154203.jpg)

从森林到二叉树：

1. 森林里的每一棵树转换为二叉树
2. 后一棵二叉树作为前一棵二叉树的根节点的右孩子

![](C:/Users/Five/Desktop/note/img/20130916192200625.jpg)





## B树

1970年，R.Bayer和E.mccreight提出了一种适用于外查找的[树](https://baike.baidu.com/item/树/2699484)，它是一种平衡的多叉树，称为B树（或B-树、B_树）。

> Rudolf Bayer 和 Ed McCreight 于1972年，在Boeing Research Labs 工作时发明了B 树，但是他们没有解释B 代表什么意义（如果有的话）。Douglas Comer 解释说: 两位作者从来都没解释过B树的原始意义。正如我们所见，“balanced”， “broad” 或 “bushy” 可能适合。其他人建议字母“B”代表 Boeing。源自于他的赞助，不过，看起来把B树当作“Bayer”树更合适些。
>
> from维基百科



# 二叉树





一些常用概念



完全二叉树：一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（ $1\le i \le n $ ）的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。

* 完全二叉树的子节点和其父节点的编号有简单、直接的对应关系

## 基本概念和操作

### 遍历

前序遍历、中序遍历、后序遍历

中序遍历 + （前序和后序中任意一个遍历） 可以唯一确定一棵树。

前序 + 后序 无法确定，因为无法分割/判定左右子树。



### 二叉排序树

二叉排序树，Binary Search Tree，也即二叉搜索树，起具有如下特点

* 若左子树非空，则**左子树**上所有节点值均**小于根节点**的值。
* 若右子树非空，则**右子树**上所有节点值均**大于根节点**的值。

显然，二叉排序树的每一棵子树都是二叉排序树。



## 平衡二叉树

普通的二叉排序树很可能会遇到一些很尴尬的极端情况，如：

![](C:/Users/Five/Desktop/note/img/bst_degeneration.png)

上图显然还是二叉排序树，但已经几乎要退化为链表了（如果没有右边那个孤零零的101节点，就已经是链表了）。此时就需要平衡二叉树登场了。

平衡二叉树是指任意节点的子树的高度差都小于等于1的二叉树。





## 2-3树



# 堆和优先队列[^1]

堆（heap）是计算机科学中一类特殊的数据结构的统称，堆总是满足下列性质：

* 堆中某个结点的值总是不大于或不小于其父结点的值；
  * 即有大顶堆和小顶堆，对应最大或最小的元素永远在堆顶
* 堆总是一棵完全二叉树。



我也很纠结优先队列到底算线性数据结构的内容，还是算树形数据结构的内容。

经典的二叉堆（Binary Heap）是用线性结构——数组实现的。

> 但就算是二叉堆，也是用线性的数组存储了一棵完全二叉树，其之所以能直接得到其父节点在数组中的位置靠的也是完全二叉树的特性。



二项堆（Binomial Heap，注意和二叉堆Binary Heap区分）

## 二叉堆的结构和操作

一般来说，都是用二叉树来构造堆，或者说是可以被看作二叉树的数组对象。



大顶堆得到最大值这种操作就不赘述了，O(1)复杂度（2-3堆除外）

### 插入（入队）

因为二叉堆是个数组，所以显然是直接将要插入的元素放到数组的末尾

**堆化**：当一个元素插入到堆中，此时堆可能不再满足原有的性质，需要调整使之重新变成堆。

二叉堆主要就两个性质：

* 堆中某个结点的值总是不大于或不小于其父结点的值
* 堆总是一棵完全二叉树

第二点性质对二叉堆而言是默认的、先验的（即主动将数组视为二叉树），所以显然不会被破坏。

而对于第一点，由于完全二叉树的性质，可以很方便地找到节点的父节点，以大顶堆为例，只需将新插入的元素和其父元素进行比较，若父节点更小，则和父节点交换位置，并继续向上一个父节点发起比较，直到父节点比新元素大。

### 删除



### 取最值（出队）





### 第K大

第K大一般需要维护一个size为K的小顶堆，同理第K小一般需要维护大顶堆。



* 当队列内元素数量小于K时，

## 其他堆的种类和实现

下图是维基百科[^1]中给出的堆的种类

* [2–3 heap](https://en.wikipedia.org/wiki/2–3_heap)
* [B-heap](https://en.wikipedia.org/wiki/B-heap)
* [Beap](https://en.wikipedia.org/wiki/Beap)
* [Binary heap](https://en.wikipedia.org/wiki/Binary_heap)
* [Binomial heap](https://en.wikipedia.org/wiki/Binomial_heap)
* [Brodal queue](https://en.wikipedia.org/wiki/Brodal_queue)
* [*d*-ary heap](https://en.wikipedia.org/wiki/D-ary_heap)
* [Fibonacci heap](https://en.wikipedia.org/wiki/Fibonacci_heap)
* [K-D Heap](https://en.wikipedia.org/wiki/K-D_Heap)
* [Leaf heap](https://en.wikipedia.org/w/index.php?title=Leaf_heap&action=edit&redlink=1)
* [Leftist heap](https://en.wikipedia.org/wiki/Leftist_tree)
* [Pairing heap](https://en.wikipedia.org/wiki/Pairing_heap)
* [Radix heap](https://en.wikipedia.org/wiki/Radix_heap)
* [Randomized meldable heap](https://en.wikipedia.org/wiki/Randomized_meldable_heap)
* [Skew heap](https://en.wikipedia.org/wiki/Skew_heap)
* [Soft heap](https://en.wikipedia.org/wiki/Soft_heap)
* [Ternary heap](https://en.wikipedia.org/wiki/Ternary_heap)
* [Treap](https://en.wikipedia.org/wiki/Treap)
* [Weak heap](https://en.wikipedia.org/wiki/Weak_heap)

|                          Operation                           |   find-max   |  delete-max  |    insert    | increase-key |     meld     |
| :----------------------------------------------------------: | :----------: | :----------: | :----------: | :----------: | :----------: |
|     [Binary](https://en.wikipedia.org/wiki/Binary_heap)      |    *Θ*(1)    | *Θ*(log *n*) | *O*(log *n*) | *O*(log *n*) |   *Θ*(*n*)   |
|    [Leftist](https://en.wikipedia.org/wiki/Leftist_tree)     |    *Θ*(1)    | *Θ*(log *n*) | *Θ*(log *n*) | *O*(log *n*) | *Θ*(log *n*) |
|   [Binomial](https://en.wikipedia.org/wiki/Binomial_heap)    |    *Θ*(1)    | *Θ*(log *n*) |    *Θ*(1)    | *Θ*(log *n*) | *O*(log *n*) |
|  [Fibonacci](https://en.wikipedia.org/wiki/Fibonacci_heap)   |    *Θ*(1)    | *O*(log *n*) |    *Θ*(1)    |    *Θ*(1)    |    *Θ*(1)    |
|    [Pairing](https://en.wikipedia.org/wiki/Pairing_heap)     |    *Θ*(1)    | *O*(log *n*) |    *Θ*(1)    | *o*(log *n*) |    *Θ*(1)    |
|     [Brodal](https://en.wikipedia.org/wiki/Brodal_queue)     |    *Θ*(1)    | *O*(log *n*) |    *Θ*(1)    |    *Θ*(1)    |    *Θ*(1)    |
| [Rank-pairing](https://en.wikipedia.org/w/index.php?title=Rank-pairing_heap&action=edit&redlink=1) |    *Θ*(1)    | *O*(log *n*) |    *Θ*(1)    |    *Θ*(1)    |    *Θ*(1)    |
| [Strict Fibonacci](https://en.wikipedia.org/wiki/Fibonacci_heap) |    *Θ*(1)    | *O*(log *n*) |    *Θ*(1)    |    *Θ*(1)    |    *Θ*(1)    |
|      [2–3 heap](https://en.wikipedia.org/wiki/2–3_heap)      | *O*(log *n*) | *O*(log *n*) | *O*(log *n*) |    *Θ*(1)    |     *?*      |











打算细究的堆：

* 二叉堆
* 二项堆：可合并堆
* 斐波那契堆
* 2-3堆



## 堆和其他数据结构的关系





## 应用

> 流式数据中第K大/第K小元素的求解。

最暴力的方法，每一个新数据加入进行一次排序，将新数据插入到合适的位置，复杂度为K，总的复杂度为$KN$

用堆可以使得复杂度的系数为常数



以下应用还没细思，网上copy的

* 数据压缩：赫夫曼编码
* 最短路径算法：Dijkstra算法
* 最小生成树算法：Prim算法
* 事件驱动仿真：顾客排队算法





## 堆排序







[^1]: https://en.wikipedia.org/wiki/Heap_(data_structure)







