# 分布式架构

### 分布式环境面临的问题

##### 通信异常

##### 网络分区

”脑裂“，分布式系统会出现局部小集群。



##### 三态

成功、失败和超时。

网络通信的发起方无法确定是消息在去的路上的凉了还是在回来的路上凉了，也就无法确定请求是否被成功处理。



##### 节点故障

宕机。



### 由ACID引出的CAP/BASE

##### 事务特性ACID

原子性Atomicity、一致性Consistency、隔离性Isolation、持久性Durability。



##### 分布式事务

一个分布式事务可以看作是由多个分布式操作序列（子事务）组成的。

子事务的ACID可以保证，子事务组成的事务ACID特性却难以保证。



系统的可用性和严格一致性之间的冲突。

如果单方面强调严格一致性，那其可用性甚至可能会不如单机服务



##### CAP

> 一个分布式系统不可能同时满足（强）一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）



> 一致性：数据在多个副本之间是否能够保持一致的特性。不会读到脏数据。
>
> 可用性：在**有限的时间**内返回结果。搜索引擎0.2秒返回结果和Hive平台20秒返回结果都算是有限的实践。
>
> 分区容错性：任何网络分区故障，能够继续提供服务。



为什么要引入分布式集群？

* 减少（甚至避免）宕机带来的影响，高可用和容灾
* 更高的吞吐量
* 更大的容量



>分布式计算和分布式存储描述的是分布式的作用。
>
>但分布式通信说的不是分布式的作用，而是分布式面临的问题。



完美的网络通信现实中是不存在的，因此分布式集群有得必有失。

> 单机节点没有通信问题吗？
>
> 有，但单机内存的时延在纳秒数量级，这可太理想了，以至于目前的技术水平就可以视为理想的网络通信。

| 舍弃 | 结果                                                         |
| ---- | ------------------------------------------------------------ |
| A    | 遇到网络分区等故障，直接罢工不干，就是舍弃可用性。           |
| C    | 指放弃数据强一致性，而不是所有一致性。否则系统也将失去意义。 |
| P    | 将与事务相关的数据都放到同一个分布式节点上，从某种意义上来说就是退化到了单机模式，放弃了可扩展性。 |



> 强一致性：更新过的数据能被后续的访问看到
>
> 弱一致性：能容忍后续的部分或全部访问不到
>
> 最终一致性：一段时间后要求能够访问到更新后的数据



> 最终一致性的五种变种
>
> 因果一致性：
>
> 读自己所写：Read your writes
>
> 会话一致性：Session consistency
>
> 单调读一致性
>
> 单调写一致性



##### BASE

Basically Available + Soft  state + Eventually consistent.



Soft state：指允许系统中的数据存在中间状态（数据同步延时），并认为该中间状态的存在不会影响系统的整体可用性。



# 一致性协议

### 2PC和3PC

##### 2PC



##### 3PC





# 分布式协同

### 分布式互斥

排他性的资源访问，对一个资源在同一时刻只有一个程序能够访问。

##### 集中式算法

增加一个协调者进行约束和调节。每个程序在访问临界资源时，先向协调者发送请求获得锁。

若资源已经被占用，则加入等待队列。

* 优点：逻辑简单易实现
* 缺点：容易单点故障



##### 分布式算法

组播和逻辑时钟

远远超过集中式的、更为高昂的消息交互，不过消息交互平摊到了集群，可能显得不明显



分布式算法适合节点数少且变动不频繁的集群，HDFS的文件修改是典型的应用分布式算法的场景。

![HDFS文件修改流程示意图](C:/Users/Five/Desktop/note/img/1-01.png)

##### 令牌环算法

节点数目一多、资源数一多算法复杂度都急剧上升。

##### 两层结构的分布式令牌环算法

全连接图复杂度太高，就重拾树形数据结构了呗。



![](C:/Users/Five/Desktop/note/img/1-02.jpg)



### 分布式选举

##### Bully算法

在所有活着的节点中，选取ID最大的节点作为主节点。

当且仅当主节点故障或失去联系后重新选举

* Election消息，发起选举
* Alive消息，对Election消息的应答
* Victory消息，竞选成功的主节点发送的消息

![image-20200928175246470](C:/Users/Five/Desktop/note/img/\1-03.png)



##### Raft算法

* Leader，主节点
* Candidate，候选者
* Follower，从节点



1. 所有节点初始都为Follower
2. 开始选举后（或限定时间内没接收到Leader心跳），转入Candidate状态，并发送选举请求
3. 根据接收到的选举请求先后顺序回复同意与否。每一轮选举每个节点只能投出一票。
4. 若发起请求的节点得到超过半数的票，则状态转为Leader，其他节点转为Follower。
5. 当Leader任期到了（发现更大term的服务器），则降级为Follower，重新选主。

[Raft选举演示动画](http://thesecretlivesofdata.com/raft/#election)

![image-20200928175531650](C:/Users/Five/Desktop/note/img/1-04.png)



##### ZAB算法

相比较Raft增加了通过节点ID和数据ID作为参考进行选主，节点ID和数据ID越大，越优先成为主。

* Leader
* Follower
* Observer



四种状态

* Looking
* Leading
* Following
* Observing



投票信息：唯一三元组（server_id, server_zxID, epoch）

![image-20200928180043121](C:/Users/Five/Desktop/note/img/1-05.png)

![image-20200928180143738](C:/Users/Five/Desktop/note/img/1-06.png)



![image-20200928180217624](C:/Users/Five/Desktop/note/img/1-07.png)



##### 算法对比

![image-20200928180341813](C:/Users/Five/Desktop/note/img/1-08.png)



### 分布式事务





### 分布式锁

