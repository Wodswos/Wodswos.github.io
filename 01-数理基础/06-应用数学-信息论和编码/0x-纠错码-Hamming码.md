> 从普通的存储设备（光盘）到数据中心（Hadoop），数据的完整性保障是亘古不变的话题。

最简单、粗暴的方法就是存储多份。比如存储三份一样的数据，甚至更多。

> 只存两份还不行，当其中一份被篡改或损毁时（0变成1，或1变成0），你并不知道哪一份是正确的。
>
> 至少需要存三分，那么可以少数服从多数原则，有两份以上为1就为1，否则为0。（当然如果其中两份损毁了，那么就得到错误的数据，即还是损毁了）

这样一来，冗余是恐怖的，但容错效果却并不好。纠错码应运而生，汉明码是最早的纠错码。

> The basic principle of error correction is that in a vast space of all possible messages, only some subset are going to be considered valid message.



# 先验一：奇偶校验

奇偶校验很简单，就不赘述了。

它可以检测错误，但不能修复错误。当然，这种检测也是有限的，一个bit错了能察觉，两个bit错了就失效了（两个以上自然也都默认失效了，虽然奇数个错误还是能被察觉）。

> 任何错误检验或者修正方法都不能100%保证你收到的信息就是原信息。
>
> 只要噪音够多，任何一条有效信息都可能变成另一条有效（valid，个人感觉合法可能更贴切）信息

奇偶校验确实有点弱，但其用极少量冗余达到极有用（毕竟噪声只干扰1bit或奇数bit的概率很高）效果。同时也开辟了一种新的思路。

> 最容易想到，也最直接的奇偶校验的代码实现就是模2。
>
> 当然之后会发现，对于二进制，异或可能是比模2是更好的奇偶校验实现形式。



# 先验二：信息论

> 有十个篮子，每个篮子内装固定数量 $k_i$ 的鸡蛋，使得当 $x \in [0,1023]$ 时，均存在若干篮子的一个组合，该组合内的鸡蛋数量等于该 $x$。

当然这问题很简单也很直接，知道二进制的很容易把问题抽象出来，即在选取的组合内包含和不包含编号 $i$ 篮子两种情况对应0和1两种状态。

最终就是用二进制表示 0 - 1024 之间的数（只要信息是 10 bit，即取值空间是 1024 都可），即每个篮子的鸡蛋数对应二进制中该位的权值。

第一次见到这个题的时候还是高中，啥也不懂，只觉得解法确实很惊艳。

> 1000桶水，其中一桶有毒，猪喝毒水后会在15分钟内死去，想用一个小时找到这桶毒水，至少需要几头猪？[^1]
>
> 一滴毒水足以导致一头猪的死亡。死亡时间为15分钟内不确定的某个时间点。猪的承水量足够大，水桶水量足够大。
>
> 更多补充描述和讨论可参考链接[^1]。

这个问题描述就比之前要隐蔽许多，也稍稍复杂一丢丢。

可以先不考虑猪的重复利用，那么基本跟上一题一模一样：十头猪编码1-10，一千桶水用二进制编码。

| 9($2^9$) | 8    | 7    | 6    | 5    | 4    | 3    | 2    | 1($2^1$) | 0($2^0$) |
| -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | -------- | -------- |
| 0        | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0        | 1        |
| ...      | ...  | ...  | ...  | ...  | ...  | ...  | ...  | ...      | ...      |
| 1        | 1    | 1    | 1    | 1    | 0    | 1    | 0    | 0        | 0        |

一桶水的编号为n，n的二进制中k位为1，那么猪k需要喝一口该桶水。

最后，哪些猪死了，这些猪代表的位为1，其他位为0的编码，就是有毒的那桶水的编码。

再回到原问题，猪不再只有死和活两种状态了。

* 第15分钟死去
* 第30分钟死去
* 第45分钟死去
* 第60分钟死去
* 没死

每头猪能有五种状态，啥意思？五进制呗。信息论的角度很快就能算出上限，$\log_5 1000 \approx 4.292 \leq 5$，所以最少要五头猪。

给水桶五进制编码，剩下的步骤和鸡蛋篮子问题无异。

## 二分查找

对于有序的数据，二分查找是再寻常不过的操作了。

现在从编码的角度来看，当我们二分查找的时候，查找的究竟是什么呢？

假设有1023个数据，即二进制码从 0000000001-11111111111，第一次对半分，能够得到的信息是什么呢？没错，就是最高的数是0还是1，以此类推，第二次对半分，我们能得到的信息，就是次高位是0还是1。

最终确定唯一的数据编码，也即数据地址。



# 汉明码（15-11）

> 如果仅仅是认识汉明码，前面两个先验不是必须的，但如果要去掉汉明码的神秘面纱，那么之前的先验又是必要的。
>
> 人们通常将香农于1948年10月发表于《贝尔系统技术学报》上的论文《A Mathematical Theory of Communication》（通信的数学理论）作为现代信息论研究的开端。
>
> 在1950年，Hamming发表了今日所称的汉明码。几乎是同一个时期的事。
>
> 香农的伟大毋庸置疑，但也可以看到时代的风起云涌，许多人在坐着相关或者铺垫性的工作，没有香农，也许也会在若干年后有臭农。

上世纪四十年代，在贝尔实验室（又双叒叕是贝尔实验室），Hamming被数据错误困扰，发明了汉明码。

（看下图风格知来源 3Blue1Brown）

![image-20201217214433889](C:\Users\Five\Desktop\note\img\image-20201217214433889.png)

从某种程度上来讲，Hamming 码解决了这样一个问题：如何通过 $\lceil \log_2N \rceil$ 位比特，确定$N$位数据中出错的那一位。显然这个之前的二进制编码是一回事。

完全可以映射到简化的“毒水”问题，数据地址就是水桶编号，错误的数据就是那桶有毒的水，奇偶校验就好比用猪喝水的测试。

若第 $n$ 位奇偶校验正确（猪没死），则说明错误数据的二进制地址第n位为0，反之，若错误，说明错误数据第n位为1



> 也可以说，就是二分查找问题，奇偶校验出现错误就说明错误数据地址的该位1。
>
> 如果所有的奇偶校验都正确，会发现错误地址指向0000，所以，很自然地会想0000这个地址不适合用于存储数据，不如用作整体的奇偶校验。



以上讨论都基于假设：数据错且仅错一位，就像假设只有一桶水有毒一样。但在数据存储，显然不一定出错，甚至我们本就希望它尽量不要出错。

那么面对不是有一个位出错的情况该怎么办？比如所有奇偶校验都正确无误的情况该怎么判断？所以一定要有一个结果（编码）代表无错的那种可能。

一般来说，若数据无误最终得到的数据地址会是0000，即第一个数。所以一个合理的做法是：第一个位置（即所有奇偶校验都正确的情况下得到的地址）不用于存储数据，而是将该地址作为数据正确无需纠错这种情况的编码。

当所有15位（11位数据码和4位冗余控制码）填充完毕后，通过首位对整体奇偶校验。

如此一来，我们通过正常的检验步骤，发现至少存在一位错误，再检查首位，发现整体的奇偶校验正确，那么说明错了两处（当然也可能是四处）。即如果错了两处数据，也能通过这一比特位发现。



Talk is cheap, show the code.

```python
def hamming_code_15_11(data):
    wrong_data_address = 0

    for weight in range(4):  # party check
        check_sum = 0
        for address in range(16):
            if address // (2 ** weight) % 2:
                check_sum += data[address]
        if check_sum % 2:  # check_sum为奇数说明奇偶校验显示数据错误
            wrong_data_address += 2 ** weight

    if wrong_data_address:
        if sum(data) % 2:  # 错了一位的情况
            data[wrong_data_address] = 1 - data[wrong_data_address]  # Python只有引用，函数自然也传引用，所以这种操作会修改原数据，实践中极不推荐，但我这里就不讲究了
        else:
            return "至少错了两位"

    return data
```



> 将控制位放在$2^n$地址的设计，使得如果出错的那一位是控制位也能直接修改控制位。



# 一种优雅的实现

在 3Blue1Brown 的视频里仅用一行Python代码就实现了Hamming码……那一刻有感觉到羞辱和碾压。

这种实现方法基于对于异或一种更泛化的理解，即异或是不进位加法，也即相加后$\mod 2$。

> 说白了，计算机底层的加法器也是通过异或运算和与运算分别得到当前位和进位的。所以异或是不进位加法也好理解。

> 就像之前说奇偶检验时提到的，对于单个bit，异或操作可能是一种很好的模2实现方法。
>
> 虽然我个人的认知过程是奇偶校验 → 想到求和模2 → 见识到异或操作，但异或操作和求和模2都是实现形式，从结果上看异或操作要比模2优雅、高效不止一点点。

3Blue1Brown在视频里给出了一个神奇的方法，如图所示，将所有值为1的地址进行异或操作，最后得到的结果就是错误码的地址（如果有且只有一个错误）：

![image-20201221170531676](C:\Users\Five\Desktop\note\img\image-20201221170531676.png)

为什么可以这样做？我从之前已有的代码出发，可以有如下思考过程（很粗糙，很原始，也不优雅）：

1. 所有地址末位为1的值进行求和模2（奇偶检验）得到错误码地址末位→
2. 所有值为1的地址末位进行求和模2（奇偶校验）得到错误码地址末位→
3. 所有值为1的地址进行异或操作得到错误码地址末位→
4. （当我们重新聚焦到前三位，发现将模2处理变成异或之后，四个位的操作已经融合在一步了）

> 1→2为什么能满足呢？因为这两步可以理解为满足条件“地址末位为1”且“值为1”的数量，（虽然各自加了一些不同的项，但那些项都是0，显然不影响结果），然后模2。
>
> 2→3是之前在介绍异或的时候就提到的，用异或代替模2。

3Blue1Brown给出的思路更为巧妙。他将设置控制位的过程，理解为将图右边的竖式每一位都调零的过程。

而当数据在传输过程/存储过程中遭到损伤，若某个0变成了某个1，完全可以视为在右边的原来已经调零的竖式中又加上该bit的地址，那么最后竖式得到的结果自然就是错误的地址本身（`0^x=x`，此处`^`是指异或）

> 某个1变成了某个0的情况会有点绕，也体现异或的神奇之处，反正最后完全可以归到跟0变成1一样的情况。限于文笔，这里不细写了。可参见3Blue1Brown的视频。

最后是一行Python代码实现Hamming码：

```python
from functools import reduce
def hamming_code_enhanced_15_11(bits):
	return reduce(lambda x,y: x^y, [i for i,bit in enumerate(bits) if bit])
```

没错，核心代码真的只有一行。而且代码不仅可以用于15-11的汉明码，更大的数据块也一样适用。



> 可以如3Blue1Brown的演示的一样用`numpy.random.randint(0,2,16)`生成随机数据，然后调整`0,1,2,4,8`位的五个控制码，得到一组“正确”的数据。

# 矩阵形式

![image-20201221183309099](C:\Users\Five\Desktop\note\img\image-20201221183309099.png)



留坑，待填。（大概率不填）

# Hamming码效果评价和验证

## Hamming码的不足

* Hamming码能识别两个及以上偶数个错误，但无法修改。
* Hamming码能识别三个及以上奇数个错误，而且会修改，但这种修改是错误的，即把错的数据改成错的。
* 极端情况下，信息可能会错误成另外一组“正确”（指符合Hamming码规范）的信息，即「验证正确」不等于「数据传输无误」。



## 打散存储

大量的错误很有可能集中在某一块区域（应该不难理解），因此在传输和存储时，可以把经过汉明码处理的、有序的数据打散存储。

这样，接受/读取的时候，再将打乱的数据对称恢复到原数据后，错误大概率就会分散到各处。

# 电路实现

## Ben Eater

留坑，待填。（大概率不填）





[^1]:https://www.zhihu.com/question/60227816/answer/1274071217
[^2]:https://www.bilibili.com/video/BV1pV411y7E8