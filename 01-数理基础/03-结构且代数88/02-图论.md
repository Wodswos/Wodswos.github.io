# 基本概念

集合论中二元关系的关系图都是图论中的图。

图论只关心点之间的连线的情况，而不关心点的位置。

### 定义

引入A、B两个集合的无序积：
$$
\{\{a,b\}|a\in A  \and b \in B\}
$$
则有无向图G：

* 有序二元组<V，E>
* V为非空有穷集（顶点集）
* E为无序积V&V的有穷多重子集（边集）

有向图D：

* 有序二元组<V，E>
* V为非空有穷集（顶点集）
* E为笛卡尔积V×V的有穷多重子集（边集）



阶、平凡图、标定图、基图、关联、相邻、邻域、子图、母图、完全图等记忆性基础概念不再赘述。



> 握手定理：所有顶点的度数之和是边数的两倍。



### 通路、回路、连通性

> 农夫、狼、羊、菜过河问题：
>
> 农夫需要把狼、羊、菜和自己运到河对岸去，只有农夫能够划船，而且船比较小，除农夫之外每次只能运一种东西，如果没有农夫看着，羊会偷吃菜，狼会吃羊。
>
> 请考虑一种方法，让农夫能够安全地安排这些东西和他自己过河。



第一次看到这题在高中，当时对把羊运来运去的操作惊为天人，印象深刻。



却不知这题背后隐藏着更深刻、更普遍的规则——状态描述（DP的核心）和连通问题（图论）。

将每种情况一一映射为状态，再将状态视为图的顶点进一步编程求解。



对图求通路的编程解决方案-暴力BFS，复杂度$n^3$。

```python
def if_access(point_a_index,point_b_index,v,e):
    queue = []
    for i,edge in enumrate(e[point_a_index]):
        if edge = 1:
            queue.append(i)
   	deeper_queue = []
    # 避免环路无限循环，最大搜索深度为元素个数n
    for depth in range(len(v)):
        for index in queue:
	        if e[queue[i]][point_b_index] = 1:
    	        return True
        	else:
            	for i,edge in enumrate(e[index]):
        			if edge = 1:
            			deeper_queue.append(i)
		queue, deeper_queue = deeper_queue, []
        
    return False
```





> 有向图D是强连通图当且仅当D中存在经过每个顶点至少一次的回路。





### 图的矩阵表述

矩阵和图，天作之合，代数和几何的桥梁，不赘述了。

在计算机中的图显然都是用数组存储——即矩阵。



# 欧拉图和哈密顿图



# 树



# 平面图





# 支配集、覆盖集、独立集、匹配与着色

